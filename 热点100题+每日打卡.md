# leetcode

## 除自身以外数组的乘积

https://leetcode-cn.com/problems/product-of-array-except-self/

<font color=green>思想</font>:

+ 定义一个变量初始值为1
+ 从左到右，先将k值赋给当前位置的结果数组，再将k值乘以输入数组当前位置的值
+ 遍历一次得到的结果为每个数左边的数的乘积
+ 类似地，从右到左再遍历一次

<font color=red>代码</font>

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[]ans = new int[nums.length];
        int k = 1; 
        for(int i = 0;i < ans.length;i++){
            ans[i] = k;
            k *= nums[i];
        }
        k = 1;
        for(int i = ans.length-1;i >= 0;i--){
            ans[i] *= k;
            k *= nums[i];
        }
        return ans;
    }
}
```

## 两数相加

https://leetcode-cn.com/problems/add-two-numbers/

<font color=green>思路</font>

+ 因为是逆序存储的所以不用考虑补齐问题，将null变为0并定义一个变量存储进位项，从前往后计算即可（要考虑最后只有进位两数都为null的情况）

<font color=red>代码</font>

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            int upper = 0;
            ListNode ans = new ListNode(0);
            ListNode curr = ans;
            int num1 = 0, num2 = 0;
            while(l1!=null || l2!=null){
                num1 = l1!=null ? l1.val : 0;
                num2 = l2!=null ? l2.val : 0;
                curr.next = new ListNode((num1+num2+upper)%10);
                upper = (num1+num2+upper)/10;
                curr = curr.next;
                if(l1 != null)
                    l1=l1.next;
                if(l2 != null)
                    l2=l2.next;
            }
            if(upper > 0)
                curr.next = new ListNode(upper);
            return ans.next;
    }
}
```

## 顺时针打印矩阵

https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/

<font color = green>思路</font>

+ 分别定义四个变量记录四个角的位置
+ 走到边界时就对标记进行更改

<font color=red>代码</font>

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int index = 0;
        int l = 0, t = 0, r = matrix[0].length - 1, b = matrix.length - 1;
        int[]ans = new int[(r + 1)*(b + 1)];
        while(true){
            for(int i = l; i <= r; i++) ans[index++] = matrix[t][i];
            if(++t > b) break;
            for(int i = t; i <= b; i++) ans[index++] = matrix[i][r];
            if(--r < l) break;
            for(int i = r; i >= l; i--) ans[index++] = matrix[b][i];
            if(--b < t) break;
            for(int i = b; i >= t; i--) ans[index++] = matrix[i][l];
            if(++l > r) break;
        }
        return ans;
    }
}
```

## 无重复字符串的最长子串

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

<font color=green>思路</font>

+ 利用队列，遇到重复字符时，队头移到被重复字符的下一位。
+ 利用队列思想，用哈希表实现。

<font color=red>代码</font>

```java
import java.util.HashMap;
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() == 0) return 0;
        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        int front = 0;
        int maxlen = 0;
        for(int i = 0;i < s.length();i++){
            if(map.containsKey(s.charAt(i)))
                front = Math.max(front, map.get(s.charAt(i)) + 1);
            map.put(s.charAt(i), i);
            maxlen = Math.max(maxlen, i - front + 1);
        }
        return maxlen;
    }
}
```

## 最长连续序列

https://leetcode-cn.com/problems/longest-consecutive-sequence/

<font color=green>思路</font>

+ 将所有数全部存到一个哈希表中。
+ 对没有前序的数进行后序的哈希查找，更新最长连续序列长度。

<font color=red>代码</font>

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int lengthmax = 0;
        Set<Integer> num_set = new HashSet<Integer>();
        for(int num : nums)
            num_set.add(num);
        for(int num : nums){
            if(!num_set.contains(num - 1)){
                int currentlength = 1;
                while(num_set.contains(++num)){
                    currentlength += 1;
                }
                lengthmax = Math.max(lengthmax,currentlength);
            }
        }
        return lengthmax;
    }
}
```

## 把数字翻译成字符串的方案数

https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/

<font color=green>思路</font>

+ 动态规划问题

+ 设第i位有f(i)种方案，第i+1位有f(i+1)中方案；
+ 如果第i+2位和第i+1位可以组成(>=10&&<=25)的数，那么用组合成功的数在此处能实现的方案就有f(i)种，不用组合的数的方案就有f(i+1)中，此处的方案就一共有f(i)+f(i+1)种；
+ 如果第i+2位和第i+1位不能组成(>=10&&<=25)的数，那么在在此处就只有f(i+1)种方案；
+ 可以用遍历字符串和取位的方法(从后往前较好)遍历该数的每一位，记录在每一位的方案，最终的那一位的方案就是总方案数。

<font color=red>代码</font>

```java
class Solution {
    public int translateNum(int num) {
        int a = 1, b = 1, c, x, y = num % 10;
        while(num != 0){
            num /= 10;
            x = num % 10;
            c = x * 10 + y;
            y = x;
            c = (c >= 10 && c <= 25) ? a + b : a;
            b = a;
            a = c;
        }
        return a;
    }
}
```

## 回文数

https://leetcode-cn.com/problems/palindrome-number/

<font color=green>思路</font>

1. 存到一个StringBuffer中使用reverse函数求得倒序字符串，进行对比。
2. 初始化一个长整型(避免数值溢出)为0，循环取出原整型数的尾数放到长整型尾数，最后做比较。

<font color=red>代码</font>

```java
class Solution {
	public boolean isPalindrome(int x) {
        String s = "" + x;
        StringBuffer sb = new StringBuffer(x);
        String res = sb.reverse().toString();
        return s.compareTo(res) == 0 ? true : false;
    }
}
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x < 0) return false;
        long res = 0, num = x;
        for(;x > 0;res = res*10 + x%10,x /= 10);
        return res == num ? true : false;
    }
}
```

## 三数之和(求三数和等于0的不重复序列)

https://leetcode-cn.com/problems/3sum/

<font color=green>思路</font>

+ 先将数组排序
+ 从第一个数开始，找出后面与之和为0的两个数(利用从两头向中间遍历的办法)

<font color=red>代码</font>

```java
import java.util.HashMap;
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return res;
        Arrays.sort(nums);
        for(int i = 0; i < len; i++) {
            if(nums[i] > 0) break;
            int left = i + 1, right = len - 1;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            while(right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(right > left && nums[left] == nums[left + 1]) left++;
                    while(right > left && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } 
                if(sum > 0) right--;
                if(sum < 0) left++;
            }
        }
        return res;
    }
}
```

## 每日温度(求再等几天温度会升高)

https://leetcode-cn.com/problems/daily-temperatures/

<font color=green>思路</font>

1. 暴力算法，依次遍历。
2. 利用栈的方法，新入栈下标元素大于栈顶下标元素，则出栈，两下标的差值就是所求结果。
3. 动态规划思想，从后往前遍历，最后一位必定为0，每次判断当前位置与之后一位的大小，如果后一位不大于当前位置就继续后移到比后一位大的数的位置，直到找到比当前位大的数，否则结果为0。

<font color=red>代码</font>

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int ans[] = new int[T.length];
        for(int i = 0; i < T.length - 1; i++) {
            for(int j = i + 1; j < T.length; j++) {
                if(T[j] > T[i]){
                    ans[i] = j - i;
                    break;
                }
                if(j == T.length - 1) ans[i] = 0;
            }
        }
        ans[T.length - 1] = 0;
        return ans;
    }
}
```

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int ans[] = new int[T.length];
        Stack<Integer> stack = new Stack<Integer>();
        for(int i = 0; i < T.length; i++) {
            while(!stack.empty() && T[i] > T[stack.peek()]) {
                ans[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            stack.add(i);
        }
        ans[T.length - 1] = 0;
        return ans;
    }
}
```

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int ans[] = new int[T.length];
        ans[T.length - 1] = 0;
        for(int i = T.length - 2; i >= 0; i--) {
           for(int j = i + 1; j < T.length; j += ans[j]) {
               if(T[i] < T[j]) {
                   ans[i] = j - i;
                   break;
               }
               else if(ans[j] == 0){
                   ans[i] = 0;
                   break;
               }
           }
        }
        return ans;
    }
}
```

## 买卖股票的最高利润

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

<font color=green>思路</font>

+ 最后一天的利润必定是0，从后往前遍历；
+ 第`i-1`天的最高利润为`price[i] - price[i-1] + 第i天的最高利润`若计算得负数则置0；
+ 保存遍历过程中最大的利润，最后结果即为最高利润。

<font color=red>代码</font>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max = 0,curr = 0;
        for(int i = prices.length - 1; i > 0; i--) {
            curr = prices[i] - prices[i - 1] + curr;
            curr = curr < 0 ? 0 : curr;
            max = max > curr ? max : curr;
        }
        return max;
    }
}
```

<font color=green>思路</font>

+ 每天都有持有股票和未持有股票两个状态；
+ 分别计算两状态的最高利润；
+ 当天持有股票的最高利润为前一天持有股票的最高利润，或者当天买入；
+ 当天未持有股票的最高利润为前一天持有股票当天卖出，或者前一天未持有股票的利润；
+ <font color=red>注意</font>：仅允许一次交易，故买入股票时应当用从未持有股票的利润`0`来计算

```java
class Solution {
	public int maxProfit(int[] prices) {
        int dp_i0 = 0; //当天未持有股票的利润
        int dp_i1 = -prices[0]; //当天持有股票的利润
        for(int i = 1; i < prices.length; ++i) {
            dp_i0 = Math.max(dp_i0, dp_i1 + prices[i]);
            dp_i1 = Math.max(dp_i1, -prices[i]); //仅允许一次交易，故为'-prices[i]'
        }
        return dp_i0; //最后一天必然是卖出股票收益最高
    }
}
```

## 股票最高利润（含冷冻期）

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

<font color=green>思路</font> `该思路可用作所有股票题目的思维方式`

+ 每天只可能有两种状态，一种是持有股票，一种是没有股票；

+ 持有股票的情况分为两种：

  > 前前天没有股票（因为冷冻期一天），今天买入
  >
  > 前一天持有股票

+ 没有股票的情况分为两种：

  > 前一天持有股票，今天卖出
  >
  > 前一天没有股票

+ 求每天两种大情况下的最大值并保存；
+ 最后一天没有股票的情况即为最高利润（最后一天必然要卖出才会获得最高利润）。

<font color=red>代码</font>

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int dp_i0 = 0, dp_i1 = -prices[0];
        int dp_pre0 = 0;
        for(int i = 1; i < prices.length; i++) {
            int temp = dp_i0;
            dp_i0 = Math.max(dp_i0, dp_i1 + prices[i]);
            dp_i1 = Math.max(dp_i1, dp_pre0 - prices[i]);
            dp_pre0 = temp;
        }
        return dp_i0;
    }
}
```

## 二叉树的中序遍历

https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

<font color=green>思路</font>

1. 利用栈来迭代

   > 若当前节点不为空，将当前节点入栈，将左节点全部入栈，直到null
   >
   > 栈顶出栈，值存入list，将其右节点置为当前节点
   >
   > 重复以上两步直到栈空

2. 递归

   > 左节点递归调用
   >
   > 当前节点值存入list
   >
   > 右节点递归调用

<font color=red>代码</font>

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        Stack<TreeNode> inorder = new Stack<TreeNode>();
        TreeNode curr = root;
        while(curr != null || !inorder.empty()) {
            while(curr!= null){
                inorder.push(curr);
                curr = curr.left;
            } 
            curr = inorder.pop();
            ans.add(curr.val);
            curr = curr.right;   
        }
        return ans;
    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        inorder(root, ans);
        return ans;
    }
    public void inorder(TreeNode root, List<Integer> ans) {
        if(root != null) {
            if(root.left != null) inorder(root.left, ans);
            ans.add(root.val);
            if(root.right != null) inorder(root.right, ans);
        }
    }
}
```

## 爬楼梯

https://leetcode-cn.com/problems/climbing-stairs/submissions/

<font color=green>思路</font>

+ 爬0阶只有1种方法，爬1阶有1种方法；
+ 爬n阶有f(n-1)+f(n-2)种方法；

<font color=red>代码</font>

```java
class Solution {
    public int climbStairs(int n) {
        int[] ans = new int[n + 1];
        ans[0] = 1;
        ans[1] = 1;
        for(int i = 2; i <= n; i++) {
            ans[i] = ans[i - 1] + ans[i - 2];
        } 
        return ans[n];
    }
}
```

## 转变数组后最接近目标值的数组和

https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/

<font color=green>思路</font>

+ 从第一个开始遍历；
+ 碰到大于、目标值减去前n项和、除以剩余项数的值的数时返回该平均值（四舍五入）；
+ 如果到数组末端则直接返回数组最后一位。

<font color=red>代码</font>

```java
class Solution {
    public int findBestValue(int[] arr, int target) {
        if(arr.length == 0) return 0;
        Arrays.sort(arr);
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            // int ans = (target - sum) / (arr.length - i);
            int ans = getAvg(target - sum, arr.length - i);
            if(arr[i] > ans) return ans;
            sum += arr[i];
        }
        return arr[arr.length - 1];
    }

    public int getAvg(int sum, int n) {
        int ans = sum / n;
        int reminder = sum % n;
        if(reminder == 0) return ans;
        int lower = sum - reminder;
        int upper = lower + n;
        return sum - lower > upper - sum ? upper / n : lower / n;
    }
}
```

## 二叉树的层序遍历

https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

<font color=green>思路</font>

+ 利用队列对树进行广度优先遍历。
+ 深度优先遍历也可以解决，通过每下一层增加一个数组，同时处理多个一维数组解决。

<font color=red>代码</font>

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);
        while(!queue.isEmpty()) {
            int count = queue.size();
            List<Integer> le = new ArrayList<Integer>();
            while(count > 0){
                TreeNode curr = queue.poll();
                le.add(curr.val);
                if(curr.left != null) queue.add(curr.left);
                if(curr.right != null) queue.add(curr.right);
                count--;
            }
            ans.add(le);
        } 
        return ans;
    }
}
```

## 最长公共前缀

https://leetcode-cn.com/problems/longest-common-prefix/

<font color=green>思路</font>

+ 暴力算法
+ 对字符串数组进行排序，排序后的第一个和最后一个字符串的公共前缀即为所有的公共前缀；

<font color=red>代码</font>

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        char c;
        String ans = "";
        if(strs.length == 0) return ans;
        for(int i = 0; i < strs[0].length(); i++) {
            c = strs[0].charAt(i);
            for(int j = 1; j < strs.length; j++) {
                if(strs[j].length() - 1 < i || c != strs[j].charAt(i))
                    return ans;
            }
            ans += c;
        }
        return ans;
    }
}
```

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0) return "";
        Arrays.sort(strs);
        String min = strs[0];
        String max = strs[strs.length - 1];
        for(int i = 0; i < min.length(); ++i) {
            if(min.charAt(i) != max.charAt(i)) {
                min = min.substring(0, i);
            }
        }
        return min;
    }
}
```

## 戳气球

https://leetcode-cn.com/problems/burst-balloons/

<font color=green>思路</font>

`动态规划`+`分治算法`

+ 设`dp[i][j]`是戳i和j中间的任意气球可以得到的最大硬币数；
+ 则戳第k(i<k<j)个气球得到的最大硬币数为`dp[i][k] + dp[k][j] + num[i]*num[k]*num[j] `;
+ 若i和j相邻，则`dp[i][j] = 0`此为分治法思想；
+ 因为计算每一个`dp[i][j]`时可能会用到之前计算过的值，我们按照分治算法的回溯规律使每个值只用计算一次，如先计算`dp[0][1]`和`dp[1][2]`再计算`dp[0][2]`,相应地再来算`dp[2][4]`和`dp[0][4]`;
+ 由以上步骤，最后得到的`dp[0][num.length-1]`便是最终结果。

<font color=red>代码</font>

```java
class Solution {
    public int maxCoins(int[] nums) {
        if(nums == null) return 0;
        int length = nums.length;
        int[]nums2 = new int[length + 2];
        System.arraycopy(nums, 0, nums2, 1, length);
        nums2[0] = 1;
        nums2[length + 1] = 1;
        length = nums2.length;

        int[][]dp = new int[length][length];
        for(int i = length - 1; i > -1; i--) {
            for(int j = i + 1; j < length; j++) {
                int max = 0;
                for(int k = i + 1; k < j; k++) {
                    int temp = dp[i][k] + dp[k][j] + nums2[i] * nums2[k] * nums2[j];
                    max = temp > max ? temp : max;
                }
                dp[i][j] = max;
            }
        }  
        return dp[0][length - 1];
    }
}
```

## 最佳观光组合

https://leetcode-cn.com/problems/best-sightseeing-pair/

<font color=green>思路</font>

+ 存一个到达目前位置之前景点的最高分；
+ 因为每两个相邻景点之间的距离都是1，只需要拿目前的最高分和当前景点的得分作比较；
+ 最高分即之前景点的最高分减1加上当前景点得分，取最大值即可。

<font color=red>代码</font>

```java
class Solution {
    public int maxScoreSightseeingPair(int[] A) {
        int best_first_score = A[0];
        int ans = 0;
        for(int i = 1; i < A.length; i++) {
            ans = Math.max(best_first_score - 1 + A[i], ans);
            best_first_score = Math.max(best_first_score - 1, A[i]);
        }
        return ans;
    }
}
```

## 从先序遍历还原二叉树

https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/

<font color=green>思路</font>

+ 将第一个数先读出(读数时注意不一定是一位数)并入栈；
+ 读取`-`的个数，再读入第二个数；
+ 判断栈中元素的个数是否大于当前循环读到的`-`的个数，若是则出栈；
+ 当两者个数相等时，当前元素即是栈顶元素的子节点；
+ 判断其有无左子树，相应地赋值给它的左/右子树；
+ 当前元素入栈，`-`个数置0。

<font color=red>代码</font>

```java
class Solution {
    public TreeNode recoverFromPreorder(String S) {
        // if(S.length() == 0) return new TreeNode();
        char[] str = S.toCharArray();
        int count = 0;
        int num = 0;
        int i = 0;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(i < str.length && str[i] != '-') num = num*10 + (str[i++] - '0');
        TreeNode root = new TreeNode(num);
        num = 0;
        stack.push(root);
        for(; i < str.length; i++) {
            while(str[i++] == '-') count++;
            i--;
            while(i < str.length && str[i] != '-') num = num*10 + (str[i++] - '0');
            i--;
            TreeNode curr = new TreeNode(num);
            while(stack.size() > count) stack.pop();
            if(stack.peek().left == null) stack.peek().left = curr;
            else stack.peek().right = curr;
            stack.push(curr);
            count = 0;
            num = 0;
        }
        return root;
    }
}
```

## 零钱兑换

https://leetcode-cn.com/problems/coin-change/

<font color=green>思路</font>

1. 动态规划

   > + 定义一个数组`dp[amount+1]`，存储兑换amount所需要的最小硬币数；
   > + 自底向上计算出全部dp值，`dp[amount]`即为最终答案。

2. 贪心 + dfs

   > + 从最大面值的硬币开始，拿出能接受的最大值，再依次向小面值取；
   > + 如果不能成功兑换则回溯将上一面值硬币数减一，进行多次修剪。

<font color=red>代码</font>

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for(int i = 1; i <= amount; i++) {
            int min = Integer.MAX_VALUE;
            for(int j = 0; j < coins.length; j++)
                if(i - coins[j] >= 0 && dp[i - coins[j]] < min) 
                    min = dp[i - coins[j]];
            dp[i] = min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min + 1;
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```

```java
class Solution {
    int ans = Integer.MAX_VALUE;
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        addcoin(coins, amount, coins.length - 1, 0);
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
    public void addcoin(int[] coins, int amount, int index,int count) {
        if(amount == 0) {
            ans = count < ans ? count : ans;
            return;
        }
        if(index < 0) return;
        int k = amount / coins[index];
        while(k >= 0 && k + count < ans) {
            addcoin(coins, amount - k * coins[index], index - 1, count + k);
            --k;
        }
    }
}
```

## 验证回文串

https://leetcode-cn.com/problems/valid-palindrome/

<font color=green>思路</font>

+ 将字符串转换成数组，设定两个指针，分别指向数组头和尾；
+ 从两端向中间遍历，不是字母和数字就直接跳过；
+ 判断两个字符是不是相同的或者同为字母时是不是只是大小写不同（注意必须判断同为字母时）；
+ 当头指针超过尾指针时即为回文串。

<font color=red>代码</font>

```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s.length() == 0) return true;
        char[] charlist = s.toCharArray();
        int i = 0;
        int j = charlist.length - 1;
        while(i < j) {
            while(!pass(charlist[i]) && i < j) i++;
            while(!pass(charlist[j]) && i < j) j--;
            if(i >= j) break;
            if (charlist[i] - charlist[j] != 0 && (Math.abs(charlist[i] - charlist[j]) != 32 || (charlist[i] < 'A' || charlist[j] < 'A'))) return false;
            i++; j--;
        }
        return true;
    }

    public boolean pass(char c) {
        if(c <= 'z' && c >= 'a') return true;
        else if(c <= 'Z' && c >= 'A') return true;
        else if(c <= '9' && c >= '0') return true;
        else return false;
    }
}
```

## 组合总和

https://leetcode-cn.com/problems/combination-sum/

<font color=green>思路</font>

+ 回溯 + dfs剪枝

  > 利用减法的方法，将当前位置的数值输出，知道剩余目标值小于当前值；
  >
  > 移到下一位置，重复上一动作，直到目标值等于0，若目标值小于零则回溯；
  >
  > 回溯时去掉最后一次减掉的值，用其下一位置的值继续递归调用。

<font color=red>代码</font>

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        combinationSum(candidates, target, 0, new Stack<Integer>());
        return ans;
    }

    public void combinationSum(int[] candidates, int target, int index, Stack<Integer> list) {
        if(target == 0) {
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int i = index; i < candidates.length; i++) {
            if(target < candidates[i]) continue;
            list.push(candidates[i]);
            combinationSum(candidates, target - candidates[i], i, list);
            list.pop();
        }
    }
}
```

## 从前序与中序遍历序列构造二叉树

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

<font color=green>思路</font>

+ 顺序遍历前序序列，利用中序序列切割出当前节点的左右子树；
+ 递归调用，返回根节点。

<font color=red>代码</font>

```java
class Solution {
    int index = 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder.length == 0 || inorder.length == 0) return null;
        HashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();
        for(int i = 0; i < inorder.length; i++) hm.put(inorder[i], i);
        TreeNode root = buildTree(preorder, 0, preorder.length - 1, hm);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int start, int end, HashMap<Integer, Integer> hm) {
        int curr = preorder[index];
        TreeNode root = new TreeNode(curr);
        if(start == end) {
            root.left = null;
            root.right = null;
        }
        else {
            if(hm.get(curr) > start) {
                index++;
                root.left = buildTree(preorder, start, hm.get(curr) - 1, hm);
            }
            else root.left = null;
            if(hm.get(curr) < end) {
                index++;
                root.right = buildTree(preorder, hm.get(curr) + 1, end, hm);
            }
            else root.right = null;
        }
        return root;
    }
}
```

## 二叉树中的最大和路径

https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

<font color=green>思路</font>

+ 初始化最大值为`Integer.MIN_VALUE`；
+ 从根节点起，递归判断左右子树的最大和；
+ 选出目前最大和与经过当前节点的最大和的最大值；
+ 将当前节点值与左右子树的最大和的和返回给上游；
+ 最后的`max`的值就为最大值。

<font color=red>代码</font>

```java
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return max;
    }
    
    public int dfs(TreeNode root) {
        if(root == null) return 0;
        int left = Math.max(0,dfs(root.left));
        int right = Math.max(0,dfs(root.right));
        max = Math.max(max, root.val + left + right);
        return root.val + Math.max(left, right);
    }
}
```

## 盛最多水的容器

https://leetcode-cn.com/problems/container-with-most-water/

<font color=green>思路</font>

+ 头尾双指针双向遍历；
+ 注意容量按小的边来算；
+ 小边移动。

<font color=red>代码</font>

```java
class Solution {
    public int maxArea(int[] height) {
        if(height.length == 0) return 0;
        int max = 0;
        int front = 0, tail = height.length - 1;
        while(front < tail) {
            max = Math.max(Math.min(height[front], height[tail]) * (tail-front), max);
            if(height[front] > height[tail]) tail--;
            else front++;
        }
        return max;
    }
}
```

## 二进制求和

https://leetcode-cn.com/problems/add-binary/

<font color=green>思路</font>

1. 单个字符提取出来分情况判断，并记录进位。

2. 单个字符提取出来，通过运算，得到每一位的值以及进位。

<font color=red>代码</font>

```java
class Solution {
    String ans = "";
    boolean up = false;
    public String addBinary(String a, String b) {
        char[] ca = a.toCharArray();
        char[] cb = b.toCharArray();
        int alen = ca.length - 1, blen = cb.length - 1;
        while(alen >= 0 && blen >= 0) {
            if(ca[alen] != '1' && cb[blen] != '1') {
                ans = up == true ? ans + '1' : ans + '0';
                up = false;
            } 
            else if(ca[alen] == '1' && cb[blen] == '1') {
                ans = up == true ? ans + '1' : ans + '0';
                up = true;
            }
            else ans = up == true ? ans + '0' : ans + '1';
            alen--; blen--;
        }
        if(alen >= 0) rest(ca, alen);
        else if(blen >= 0) rest(cb, blen);
        if(up == true) ans += '1';
        return reverse(ans);
    }

    public void rest(char[] c, int length) {
        if(up == false) while(length >= 0) ans += c[length--];
        else {
            while(length >= 0) {
                if(c[length] == '1' && up == true) {
                    ans += '0';
                }
                else if(c[length] == '0' && up == true) {
                    ans += '1';
                    up = false;
                }
                else {
                    ans += c[length];
                }
                length--;
            }
        }
    }

    public String reverse(String s) {
        String ans = "";
        for(int i = s.length() - 1; i >= 0; i--) ans += s.charAt(i);
        return ans;
    }
}
```

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder ans = new StringBuilder();
        char[] ac = a.toCharArray();
        char[] bc = b.toCharArray();
        int ca = 0;
        for(int i = ac.length - 1, j = bc.length - 1;i >= 0 || j >= 0; i--, j--) {
            int sum = ca;
            sum += i >= 0 ? ac[i] - '0' : 0;
            sum += j >= 0 ? bc[j] - '0' : 0;
            ans.append(sum % 2);
            ca = sum / 2;
        }
        ans.append(ca == 1 ? ca : "");
        return ans.reverse().toString();
    }
}
```

## 把二叉搜索树转换为累加树

https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

<font color=green>思路</font>

+ 先把二叉树各节点的左右子树交换；
+ 先序遍历求到该节点位置之前的所有节点之和；
+ 再把二叉树各节点的左右子树交换。

<font color=red>代码</font>

```java
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if(root == null) return null;
        return reverse(midorder(reverse(root)));
    }

    public TreeNode reverse(TreeNode root) {
        if(root == null) return null;
        TreeNode temp = root.left;
        root.left = reverse(root.right);
        root.right = reverse(temp);
        return root;
    }

    public TreeNode midorder(TreeNode root) {
        if(root.left != null) midorder(root.left);
        root.val += sum;
        sum = root.val;
        if(root.right != null) midorder(root.right);
        return root;
    }
}
```

## 单词拆分

https://leetcode-cn.com/problems/word-break/

<font color=green>思路</font>

1. 动态规划

   > + 定义一个数组存储从0到当前位置的字符组成的单词是否在字典中；
   > + 从左到右，按字符数增大的顺序截取字符串；
   > + 从最后一位向前，判断左右两边的子字符串是否存在字典中；
   > + 最后`dp[s.length()]`的值即为结果。

2. DFS

   > + 

3. BFS

   > + 

<font color=red>代码</font>

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        if(s.length() == 0) return false;
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for(int i = 0; i <= s.length(); i++) {
            if(dp[i] == true) continue;
            for(int j = i; j >= 0; j--) {
                if(dp[j] == false) continue;
                String word = s.substring(j,i);
                if(wordDict.indexOf(word) != -1 && dp[j] == true) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

##  移除重复节点

https://leetcode-cn.com/problems/remove-duplicate-node-lcci/

<font color=green>思路</font>

+ 从前往后遍历，利用哈希表判断是否已遍历过相同值；
+ 若有，则删除节点。

<font color=red>代码</font>

```java
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        if(head == null) return null;
        Set<Integer> list = new HashSet<Integer>();
        ListNode curr = head;
        list.add(curr.val);
        while(curr.next != null) {
            if(list.contains(curr.next.val)) curr.next = curr.next.next;
            else {
                list.add(curr.next.val);
                curr = curr.next;
            }
        }
        return head;
    }
}
```

## 不同路径Ⅱ

https://leetcode-cn.com/problems/unique-paths-ii/

<font color=green>思路</font>

+ 设置一个缓冲区，保存两列的路径数量；
+ 每个位置的路径数量为左和上两个位置的路径数量的和；
+ 通过取余的方法确定当前路径数在缓冲区中的存储位置。

<font color=red>代码</font>

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int len = obstacleGrid.length;
        int dp_size = len*2;
        int[] dp = new int[len*2];
        for(int i = 0; i < len; i++) {
            if(obstacleGrid[i][0] != 1) dp[i] = 1;//先将第一列置1
            else {
                while(i < len) dp[i++] = 0;//当第一列有障碍时，后面的都应不可达
            }
        }
        int index = len;
        for(int j = 1; j < obstacleGrid[0].length; j++) {
            for(int i = 0 ; i < len; i++) {
                if(obstacleGrid[i][j] == 1) dp[index] = 0;//障碍物路径数置0
                else if(i == 0) dp[index] = dp[(index+len)%dp_size];//第一行只有左边可达
                else dp[index] = dp[(index+2*len-1)%dp_size] + dp[(index+len)%dp_size];
                index = (index+1) % dp_size;//缓冲区重定位
            }
        }
        return index == 0 ? dp[2*len-1]:dp[len-1];
    }
}
```

## 比特位计数

https://leetcode-cn.com/problems/counting-bits/

<font color=green>思路</font>+<font color=red>代码</font>

+ pop count

  > 利用与自身小1的数置出最后一位1的方法计算出每一个数的1的个数

  ```java
  class Solution {
      public int[] countBits(int num) {
          int[] ans = new int[num+1];
          for(int i = 0; i <= num; i++) ans[i] = popcount(i);
          return ans;
      }
      public int popcount(int num) {
          int count = 0;
          while(num != 0) {
              num &= num - 1;
              count++;
          }
          return count;
      }
  }
  ```

+ 动态规划+最高位

  >由于每相隔2的整数次方就会出现一个二进制只相差一位的数字；
  >
  >将给定范围划分成按2的幂次分割的小范围；

  ```java
  class Solution {
      public int[] countBits(int num) {
          int[] ans = new int[num+1];
          int b = 1, i = 0; 
          while(b <= num) {
              while(i < b && i +b <= num) {
                  ans[i + b] = ans[i] + 1;
                  ++i;
              }
              i = 0;
              b <<= 1;
          }
          return ans;
      }
  }
  ```

+ 动态规划+最低位

  > 一个数二进制表示的1的个数是他右移一位的数的二进制表示的1的个数加上他的二进制末位数字；

  ```java
  class Solution {
      public int[] countBits(int num) {
          int[] ans = new int[num+1];
          int i = 0; 
          while(i <= num) {
              ans[i] = ans[i >> 1] + (i & 1);
              ++i;
          }
          return ans;
      }
  }
  ```

+ 动态规划+最后设置位

  >最后设置位是二进制从右到左第一个为1的位；
  >
  >将其置0得到的数中二进制1的个数加1即是当前数二进制1的个数。

  ```java
  class Solution {
      public int[] countBits(int num) {
          int[] ans = new int[num+1];
          for(int i = 1; i <= num; ++i) ans[i] = ans[i & (i - 1)] + 1;
          return ans;
      }
  }
  ```

## 字符串解码

https://leetcode-cn.com/problems/decode-string/

<font color=green>思路</font>+<font color=red>代码</font>

+ 由于要考虑到括号内嵌套括号的问题，利用栈的方法来针对这一特性；

  > 设置两个栈分别保存括号前数字和遇到当前数字时已存留的字符串；
  >
  > 每当遇到右括号就将遇到左括号后存储的字符串与数字栈栈顶做一个处理，与字符串栈顶合并；
  >
  > 遇到左括号则入栈并重置当前存储的数值和字符串；

```java
class Solution {
    public String decodeString(String s) {
        LinkedList<String> stack_ans = new LinkedList<>();
        LinkedList<Integer> stack_num = new LinkedList<>();
        StringBuilder ans = new StringBuilder();
        int num = 0;
        for(Character c : s.toCharArray()) {
            if(c == '[') {
                stack_num.addLast(num);
                stack_ans.addLast(ans.toString());
                ans = new StringBuilder();
                num = 0;
            }
            else if(c == ']') {
                StringBuilder temp = new StringBuilder();
                int cur_num = stack_num.removeLast();
                for(int i = 0; i < cur_num; ++i) temp.append(ans);
                ans = new StringBuilder(stack_ans.removeLast() + temp);
            }
            else if(c <= '9' && c >= '0') num = num * 10 + Integer.parseInt(c + "");
            else ans.append(c);
        }
        return ans.toString();
    }
}
```

+ 利用dfs的方法

  > 遇到左括号则进入递归，保存括号内的字符串和相应右括号的位置；
  >
  > 将字符串和右括号位置返回；

```java
class Solution {
    public String decodeString(String s) {
        return dfs(s, 0)[0];
    }
    private String[] dfs(String s, int i) {
        StringBuilder res = new StringBuilder();
        int multi = 0;
        while(i < s.length()) {
            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') 
                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); 
            else if(s.charAt(i) == '[') {
                String[] tmp = dfs(s, i + 1);
                i = Integer.parseInt(tmp[0]);
                while(multi > 0) {
                    res.append(tmp[1]);
                    multi--;
                }
            }
            else if(s.charAt(i) == ']') 
                return new String[] { String.valueOf(i), res.toString() };
            else 
                res.append(s.charAt(i));
            i++;
        }
        return new String[] { res.toString() };
    } 
}
```

## 编辑距离

https://leetcode-cn.com/problems/edit-distance/

<font color=green>思路</font>+<font color=red>代码</font>

+ 用一个二维数组缓冲区记录word1的前i个字符转换成word2的前j个字符需要的步数；

+ 状态转移方程（取最小）：

  > `dp[i][j]` = `dp[i - 1][j] + 1`
  >
  > `dp[i][j]` = `dp[i][j - 1] + 1`
  >
  > `dp[i][j]` = `dp[i - 1][j - 1] + 1`

+ 当`word[i]`和`word[j]`相同时 `dp[i][j]` = `dp[i - 1][j - 1]`。
+ ![img](https://pic.leetcode-cn.com/1639bd7e5f7a85a80af26717b18040b8613050df79637d2ef51cdf5d7da9e8c1-%E5%9B%BE%E7%89%87.png)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length(), len2 = word2.length();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 0; i <= len1; ++i) {
            for(int j = 0; j <= len2; ++j) {
                if(i == 0) dp[i][j] = j;
                else if(j == 0) dp[i][j] = i;
                else if(word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
                else {
                    int min = dp[i - 1][j] >= dp[i - 1][j - 1] ? dp[i - 1][j - 1] : dp[i - 1][j];
                    min = min >= dp[i][j - 1] ? dp[i][j - 1] : min;
                    dp[i][j] = min + 1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```

## 课程表

https://leetcode-cn.com/problems/course-schedule/

<font color=green>思路</font>+<font color=red>代码</font>

+ 用拓扑排序的方法，将入度为0的节点一步一步删除，如果删不完，就说明图中有环；
+ 先计算各节点的入度，并建立邻接表；
+ 将入度为0的节点入队；
+ 出队，并将出队节点的所有邻接节点的入度减一，课程数量减一；
+ 最后判断课程数量是否为0；

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[]indegree = new int[numCourses];
        List<List<Integer>> adjency = new ArrayList<>();
        for(int i = 0; i < numCourses; i++) adjency.add(new ArrayList<Integer>());
        for(int[]cop : prerequisites) {
            ++indegree[cop[0]];//计算各节点入度
            adjency.get(cop[1]).add(cop[0]);//建立邻接表
        }
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++)
            if(indegree[i] == 0) queue.add(i);
        while(!queue.isEmpty()) {
            int pre = queue.poll();
            numCourses--;
            for(int curr : adjency.get(pre))
                if(--indegree[curr] == 0) queue.add(curr);
        }
        return numCourses == 0;
    }
}
```

## 除法求值<font color=blue>（遗留问题）</font>

https://leetcode-cn.com/problems/evaluate-division/

<font color=green>思路</font>+<font color=red>代码</font>

+ 构造并查集：a->b->c，其中a->b的边的权值为2.0，b->c的边的权值为3.0
  以计算b/a时为例，以root结点为桥梁，计算b/a的值：

  > 首先计算b/root，这里root为c，则b/c = 3.0
  >
  > 然后计算a/root，这里root为c，则a/c = a/b * b/c = 2.0 * 3.0 = 6.0
  >
  > 最后计算方程式结果：b/a = (b/root)/(a/root) = 3.0/6.0 = 0.5

```java
class Solution {
    /*
        Key:当前节点(除数)
        Value:父节点(被除数)
    */
    private Map<String,String> parents = new HashMap<>();
    /*
        Key:当前节点(除数)
        Value:(父节点到其根节点路径乘积/当前节点到其根节点路径乘积)*(当前节点到父节点) 的值
    */
    private Map<String,Double> values = new HashMap<>();
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int i = 0;
        for(List<String> e : equations) {
            //填充两个HashMap
            union(e.get(0),e.get(1),values[i++]);
        }
        i = 0;
        //结果集
        double[] ans = new double[queries.size()];
        //结果计算
        for(List<String> e : queries) {
            String parent = e.get(0);
            String child = e.get(1);
            //任意一个节点不存在则得不到结果
            if(!(parents.containsKey(parent) && parents.containsKey(child))) {
                ans[i++] = -1;
                continue;
            }
            //除数和被除数相等则结果为1
            if(parent.equals(child)) {
                ans[i++] = 1;
                continue;
            }
            //获取两节点的祖先节点
            String rootp = search(parent);
            String rootc = search(child);
            //祖先节点不同则得不到结果
            if(!rootp.equals(rootc)){
                ans[i++] = -1;
                continue;
            }
            ans[i++] = pm(child)/pm(parent);
        }
        return ans;
    }

    //遗留问题--------------------------------------------------------
    public void union(String parent, String child, double value) {//|
        //并操作(生成并查集)										 //|
        add(parent);											  //|
        add(child);												  //|
        String r1 = search(parent);								  //|
        String r2 = search(child);								  //|
        if(!r1.equals(r2)) {									  //|
            parents.put(r2,r1);									  //|
            values.put(r2,value * (pm(parent)/pm(child)));		  //|
        }														  //|
    }															  //|
    //遗留问题--------------------------------------------------------

    private void add(String node) {
        //新增独立节点
        if(!parents.containsKey(node)){
            parents.put(node,node);
            values.put(node,1.0);
        }
    }

    private String search(String node) {
        //查操作(寻找根节点)
        while(!parents.get(node).equals(node)) node = parents.get(node);
        return node; 
    } 

    private double pm(String node) {
        //计算当前节点到根节点的路径乘积
        double num = 1;
        while(!parents.get(node).equals(node)) {
            num *= values.get(node);
            node = parents.get(node);
        }
        return num;
    }
}
```

## 找到字符串所有字母异位词

https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/

<font color=green>思路</font>+<font color=red>代码</font>

+ 先用一个哈希表保存基准字符串中每个字母的出现次数；

+ 滑动窗口遍历，再用一个哈希表在遍历过程中保存每个字母出现的次数；

+ 当有一个字母出现次数与基准相等时，计数器加1，相应的滑窗左侧进行减法运算；

+ 当计数器的值等于基准哈希表的长度时，则找到一个异位词；

  <font color=red>注:</font>在使用Integer类型进行数值比较的时候最好使用`equals()`方法。使用`==`在一定数值的情况下会出现不解包做比较的现象。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if(s.length() == 0 || p.length() == 0 || s.length() < p.length()) return new ArrayList<>();
        char[] buf_s = s.toCharArray();
        char[] buf_p = p.toCharArray();
        HashMap<Character,Integer> map = new HashMap<>();
        HashMap<Character,Integer> window = new HashMap<>();
        List<Integer> ans = new ArrayList<>();
        for(char c : buf_p) {
            if(!map.containsKey(c)) map.put(c,1);
            else map.put(c,map.get(c)+1);
        }
        int left = 0, right = 0, count = 0;
        while(right < buf_s.length) {
            if(!window.containsKey(buf_s[right])) window.put(buf_s[right],1);
            else window.put(buf_s[right],window.get(buf_s[right])+1);
            if(window.get(buf_s[right]).equals(map.get(buf_s[right]))) ++count;
            ++right;
            if(right - left >= buf_p.length) {
                if(count == map.size()) ans.add(left);
                if(window.get(buf_s[left]).equals(map.get(buf_s[left]))) --count;
                window.put(buf_s[left],window.get(buf_s[left])-1);
                ++left;
            }
        }
        return ans;
    }
}
```

+ 使用数组代替哈希表

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[]R = new int[26];
        int count = 0;
        for(char c : s1.toCharArray()) {
            if(R[c - 'a'] == 0) count++;
            R[c - 'a']++;
        }
        int front = 0, tail = 0, len = s1.length();
        char[] s2_array = s2.toCharArray();
        for(front = 0; front < s2_array.length; ++front) {
            if(--R[s2_array[front] - 'a'] == 0) count--;
            if(front - tail >= len){
                if(++R[s2_array[tail] - 'a'] == 1) count++;
                tail++;
            }
            if(count == 0) return true;
        }
        return false;
    }
}
```

## 找到所有数组中消失的数字

https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/

<font color=green>思路</font>+<font color=red>代码</font>

+ 用一个新的数组存储是否访问过的标记；

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ans = new ArrayList<>();
        if(nums.length == 0) return ans;
        boolean[] exist = new boolean[nums.length];
        for(int i = 0; i < nums.length; ++i) exist[nums[i] - 1] = true;
        for(int j = 0; j < exist.length; ++j) {
            if(!exist[j]) ans.add(j + 1);
        }
        return ans;
    }
}
```

+ 将访问过的位做可逆处理在原数组上标记；

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ans = new ArrayList<>();
        if(nums.length == 0) return ans;
        int n = nums.length;
        for(int i = 0; i < n; ++i) nums[(nums[i] - 1) % n] += n;
        for(int j = 0; j < n; ++j) {
            if(nums[j] <= n) ans.add(j + 1);
        }
        return ans;
    }
}
```

## 在排序数组中查找元素的第一个和最后一个位置

https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用二分查找分别找出左端和右端；
+ 要注意判断条件是`</>`还是`<=/>=`，并且要考虑判断不存在元素的情况。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums.length == 0 || (nums[0] > target || nums[nums.length - 1] < target)){ 
            ans[0] = -1;
            ans[1] = -1;
            return ans;
        }
        int index = nums.length - 1;
        int pre_index = index;
        while(nums[index] >= target) {
            if(index == 0) break;
            pre_index = index; 
            index /= 2;
        }
        while(index < pre_index && nums[index] != target) {
            if(index == 0 && nums[index] == target) break;
            index++;
        }
        if(nums[index] != target) index = -1;
        ans[0] = index;
        index = 0;
        while(nums[index] <= target) {
            if(index == nums.length - 1) break;
            pre_index = index;
            index = (index + nums.length - 1) / 2 + 1;
        }
        while(index > pre_index && nums[index] != target) {
            if(index == nums.length - 1 && nums[index] == target) break;
            index--;
        }
        if(nums[index] != target) index = -1;
        ans[1] = index;
        return ans;
    }
}
```

## 二叉树展开为链表

https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用先右再左的后序遍历；
+ 将前一次遍历的节点作为当前节点的右子节点即可；
+ 注意要将左节点置空；

```java
class Solution {
    TreeNode pre = null;
    public void flatten(TreeNode root) {
        if(root == null) return;
        flatten(root.right);
        flatten(root.left);
        root.right = pre;
        root.left = null;
        pre = root;
    }
}
```

## 寻找重复数

https://leetcode-cn.com/problems/find-the-duplicate-number/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用对值的二分法；
+ 因为指定了数值范围，若小于当前数的数量大于当前数的数值，即说明前面有重复数字；

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int ans = 0, right = nums.length - 1;
        while(ans < right) {
            int mid = (ans + right) >>> 1;
            int count = 0;
            for(int num : nums) {
                if(num <= mid) ++count; 
            }
            if(count > mid) right = mid;
            if(count <= mid) ans = mid + 1;
        }
        return ans;
    }
}
```

## 括号生成

https://leetcode-cn.com/problems/generate-parentheses/

<font color=green>思路</font>+<font color=red>代码</font>

+ 回溯法，右括号的数量不能大于左括号的数量

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        if(n == 0) return new ArrayList<>();
        generate(n, n, "");
        return ans;
    }
    public void generate(int left, int right, String s) {
        if(left == 0 && right == 0) {
            ans.add(s);
            return;
        }
        if(left > right || left * right < 0) return;
        generate(left - 1, right, s + "(");
        generate(left, right - 1, s + ")");
    }
}
```

## 字母异位词分组

https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用字母表中每个字母的数量构造字符串做Key组成哈希表；

  ![image-20200719155136428](C:\Users\Marcus\AppData\Roaming\Typora\typora-user-images\image-20200719155136428.png)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if(strs.length == 0) return new ArrayList<>();
        Map<String, List> ans = new HashMap<String, List>();
        for(String str : strs) {
            int[] count = new int [26];
            for(char c : str.toCharArray()) count[c - 'a']++;
            StringBuilder s = new StringBuilder();
            for(int i = 0; i < 26; ++i) {
                s.append('#');
                s.append(count[i]);
            }
            String key = s.toString();
            if(!ans.containsKey(key)) ans.put(key, new ArrayList<>());
            ans.get(key).add(str);
        }
        return new ArrayList(ans.values());
    }
}
```

+ 将字符串中的字符排序做Key组成哈希表；

![image-20200719155700420](C:\Users\Marcus\AppData\Roaming\Typora\typora-user-images\image-20200719155700420.png)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if(strs.length == 0) return new ArrayList<>();
        Map<String, List> ans = new HashMap<String, List>();
        for(String str : strs) {
            char[] s = str.toCharArray();
            Arrays.sort(s);
            String key = String.valueOf(s);
            if(!ans.containsKey(key)) ans.put(key, new ArrayList<>());
            ans.get(key).add(str);
        }
        return new ArrayList(ans.values());
    }
}
```

## 合并两个有序链表

https://leetcode-cn.com/explore/interview/card/bytedance/244/linked-list-and-tree/1048/

<font color=green>思路</font>+<font color=red>代码</font>

+ 初始化一个表头，两个链表依次比较大小插入到其后；

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode ans = new ListNode();
        ListNode cur = ans;
        while(null != l1 || null != l2){
            if(null == l1) {
                cur.next = l2;
                break;
            } 
            if(null == l2) {
                cur.next = l1;
                break;
            } 
            if(l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
                cur = cur.next;
            }
            else if(l1.val > l2.val) {
                cur.next = l2;
                l2 = l2.next;
                cur = cur.next;
            }
        }
        return ans.next;
    }
}
```

+ 递归的方法依次将两个链表的节点比较大小；

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        else if (l2 == null) {
            return l1;
        }
        else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }
        else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

## 汉明距离

https://leetcode-cn.com/problems/hamming-distance/submissions/

<font color=green>思路</font>+<font color=red>代码</font>

+ 求两数的异或，再计算1的个数；
+ 其中计算1的个数用`x & (x - 1)`。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        x = x ^ y;
        int count = 0;
        while(x != 0) {
            x = x & (x - 1);
            count++;
        }
        return count;
    }
}
```

## 打家劫舍

https://leetcode-cn.com/problems/house-robber/

<font color=green>思路</font>+<font color=red>代码</font>

+ 基本动态规划思路；
+ 先判断各位置的状态，确定状态转移方法；
+ 偷的话只能是前一天不偷，不偷就存在前一天偷了和前一天不偷两种求最大值。

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        int dp_i0 = 0; //这家不偷
        int dp_i1 = nums[0]; //这家偷
        for(int i = 1; i < nums.length; ++i) {
            int temp = dp_i0;
            dp_i0 = dp_i0 >= dp_i1 ? dp_i0 : dp_i1;
            dp_i1 = temp + nums[i];
        }
        return dp_i0 >= dp_i1 ? dp_i0 : dp_i1;
    }
}
```

## 岛屿的最大面积

https://leetcode-cn.com/problems/max-area-of-island/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用深度优先遍历，碰到1 就进入递归；
+ 利用沉岛思想，将遍历的过的位置都置0，避免重复遍历过程。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for(int i = 0; i < grid.length; ++i) {
             for(int j = 0; j < grid[i].length; ++j) {
                 if(grid[i][j] == 1) ans = Math.max(ans, dfs(i, j, grid));
             }
        }
        return ans;
    }

    public int dfs(int i, int j, int[][] grid) {
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) return 0;
        int num = 1;
        grid[i][j] = 0;
        num += dfs(i + 1, j, grid);
        num += dfs(i - 1, j, grid);
        num += dfs(i, j + 1, grid);
        num += dfs(i, j - 1, grid);
        return num;
    }
}
```

## 打家劫舍Ⅲ

https://leetcode-cn.com/problems/house-robber-iii/

<font color=green>思路</font>+<font color=red>代码</font>

+ 每家包含两种状态，一种是打劫，一种是不打劫;
+ 不打劫的利润是左右两子家的最高利润之和，打劫的利润是左右两子家都不打劫的利润和;
+ 递归拜访左右两子家，最后求得最高利润。
```java
class Solution {
    public int rob(TreeNode root) {
        if(root == null) return 0;
        int left_dp = 0, right_dp = 0;
        int[] ans = dfs(root);
        return Math.max(ans[0], ans[1]);
    }

    public int[] dfs(TreeNode root) {
        int[] ans = new int[2];

        if(root == null) return ans;
        int[]left = dfs(root.left);
        int[]right = dfs(root.right);
        // int[] left = new int[2];
        // int[] right = new int[2];
        // if(root.left != null) left = dfs(root.left);
        // if(root.right != null) right = dfs(root.right);

        ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        ans[1] = left[0] + right[0] + root.val;
        return ans;
    }
}
```

## 反转链表

https://leetcode-cn.com/explore/interview/card/bytedance/244/linked-list-and-tree/1038/

<font color=green>思路</font>+<font color=red>代码</font>

+ 迭代方法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head;
        ListNode pre = null;
        ListNode next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
}
```

+ 递归方法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode next = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return next;
    }
}
```

## 实现Trie (前缀树)

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

<font color=green>思路</font>+<font color=red>代码</font>

+ 一个布尔变量保存搜索过的前缀是不是一个单词；
+ 一个长26的Trie型数组保存后续字母是否存在；
+ 通过对数组添加实体并修改布尔变量实现插入单词的操作；
+ 通过依次向下查找数组内容实现单词和前缀的查找。

```java
class Trie {

    private boolean word = false;
    private Trie[] R = new Trie[26];

    /** Initialize your data structure here. */
    public Trie() {

    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie root = this;
        for(char c : word.toCharArray()) {
            if(root.R[c - 'a'] == null) root.R[c - 'a'] = new Trie();
            root = root.R[c - 'a'];
        }
        root.word = true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie root = this;
        for(char c : word.toCharArray()) {
            if(root.R[c - 'a'] == null) return false;
            root = root.R[c - 'a'];
        }
        return root.word;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie root = this;
        for(char c : prefix.toCharArray()) {
            if(root.R[c - 'a'] == null) return false;
            root = root.R[c - 'a'];
        }
        return true;
    }
}
```

## 相交链表

https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

<font color=green>思路</font>+<font color=red>代码</font>

+ 设两个指针分别指向两个链表头，那么两个指针都走完两个链表的全长，则最后会在��交的位置碰面；
+ `pB`或`pA`在走到链表尾的时候转向对方的链表，即会在相交的地方相遇。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA, pB = headB;
        while(pA != pB) {
            if(pA == null && pB == null) return null;
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

## 翻转二叉树

https://leetcode-cn.com/problems/invert-binary-tree

<font color=green>思路</font>+<font color=red>代码</font>

+ 递归左右子树交换

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode temp = invertTree(root.left);
        root.left = invertTree(root.right);
        root.right = temp;
        return root;
    }
}
```

## 跳跃游戏

https://leetcode-cn.com/problems/jump-game/

<font color=green>思路</font>+<font color=red>代码</font>

+ 在最远距离的范围内更新最远距离；
+ 若最远距离`>=`数组最后一位则能跳到最后位置，反之不能。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int longest = 0;
        for(int i = 0; i <= longest; ++i) {
            longest = Math.max(longest, i + nums[i]);
            if(longest >= nums.length - 1) return true;
        }
        return false;
    }
}
```

## 搜索旋转排序数组

https://leetcode-cn.com/problems/search-in-rotated-sorted-array

<font color=green>思路</font>+<font color=red>代码</font>

+ nums[0] <= nums[mid]（0 - mid不包含旋转）且nums[0] <= target <= nums[mid] 时 high 向前规约；

+ nums[mid] < nums[0]（0 - mid包含旋转），target <= nums[mid] < nums[0] 时向前规约（target 在旋转位置到 mid 之间）

+ nums[mid] < nums[0]，nums[mid] < nums[0] <= target 时向前规约（target 在 0 到旋转位置之间）

+ 其他情况向后规约

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0) return -1;
        int start = 0, end = nums.length - 1;
        while(start < end) {
            int mid = (start + end) / 2;
            if((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid])) start = mid + 1;
            else end = mid;
        }
        return nums[start] == target ? start : -1;
    }
}
```

## 数组中的第K个最大元素

https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

<font color=green>思路</font>+<font color=red>代码</font>

+ 优先队列

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k + 1);
        for (int num : nums) {
            minHeap.add(num);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        return minHeap.peek();
    }
}
```

## LRU缓存机制

https://leetcode-cn.com/problems/lru-cache

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用哈希表和双向链表；
+ 将当前使用的节点放到表头，表尾即为最久未使用节点；
+ `get()`方法用哈希表的快速查找，`put()`方法则直接插入到链表头或者先删除表尾元素。

```java
class LRUCache {

    class Node {
        public int key, val;
        public Node next, prev;
        public Node(int k, int v) {
            this.key = k;
            this.val = v;
        }
    }
    class DoubleList {

        private Node head, tail;
        private int size;

        public void addFirst(Node node) {
            if (head == null) {
                head = tail = node;
            } else {
                Node n = head;
                n.prev = node;
                node.next = n;
                head = node;
            }
            size++;
        }

        public void remove(Node node) {
            if (head == node && tail == node) {
                head = null;
                tail = null;
            } else if (tail == node) {
                node.prev.next = null;
                tail = node.prev;
            } else if (head == node) {
                node.next.prev = null;
                head = node.next;
            } else {
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }
            size--;
        }

        public Node removeLast() {
            Node node = tail;
            remove(tail);
            return node;
        }

        public int size() {
            return size;
        }
    }

    private HashMap<Integer, Node> map;
    private DoubleList cache;
    private int cap;

    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }

    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        int val = map.get(key).val;
        put(key, val);
        return val;
    }

    public void put(int key, int value) {
        Node x = new Node(key, value);

        if (map.containsKey(key)){
            cache.remove(map.get(key));
            cache.addFirst(x);
            map.put(key,x);
        } else {
            if (cap == cache.size()) {
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            cache.addFirst(x);
            map.put(key,x);
        }
    }
}
```

## 柱状图中最大的矩形

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/

<font color=green>思路</font>+<font color=red>代码</font>

+ 在数组前后分别加上一个`0`作为边界。
+ 从左往右依次遍历，利用栈保存访问过的下标；
+ 若当前值小于数组中栈顶下标处的值，则表示可用数组中栈顶下标值绘制一个矩形，宽度为当前位置减去栈顶下标减一；

```java
import java.util.ArrayDeque;
import java.util.Deque; //双向队列(可用栈替换)

class Solution {
    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        if(len == 0) return 0;
        if(len == 1) return heights[0];

        int ans = 0;
        int[] newHeights = new int[len + 2];
        newHeights[0] = 0;
        System.arraycopy(heights, 0, newHeights, 1, len);
        newHeights[len + 1] = 0;
        len += 2;
        heights = newHeights;

        Deque<Integer> stack = new ArrayDeque<>(len);
        stack.addLast(0);   //设置哨兵
        for(int i = 1; i < len; ++i) {
            while(heights[i] < heights[stack.peekLast()]) {
                int currHeight = heights[stack.pollLast()];
                int currWidth = i - stack.peekLast() - 1;
                ans = Math.max(ans, currHeight * currWidth);
            }
            stack.addLast(i);
        }
        return ans;
    }
}
```

## 电话号码的字母组合

https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/

<font color=green>思路</font>+<font color=red>代码</font>

+ 初始化一个字符串数组，存储各数子对应的字母；
+ 利用递归的方法回溯暴力解答。

```java
class Solution {
    String[] letters_map = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    List<String> ans = new ArrayList<>();
    public List<String> letterCombinations(String digits) {
        if(digits.length() == 0) return new ArrayList<>();
        combinate(digits, "", 0);
        return ans;
    }

    public void combinate(String digits, String letters, int index) {
        if(index == digits.length()) {
            ans.add(letters);
            return ;
        }
        int number = digits.charAt(index) - '0';
        String get_letters = letters_map[number];
        for(int i = 0; i < get_letters.length(); ++i) 
            combinate(digits, letters + get_letters.charAt(i), index + 1);
    }
}
```

## 循环链表

https://leetcode-cn.com/problems/linked-list-cycle/

<font color=green>思路</font>+<font color=red>代码</font>

+ 哈希表存储访问过的节点，如果表中存在当前节点则说明链表循环。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> map = new HashSet<>();
        while(head != null) {
            if(map.contains(head)) return true;
            else map.add(head);
            head = head.next;
        }
        return false;
    }
}
```

+ 快慢双指针向后遍历链表，若访问到相同节点则说明链表循环；
+ 快指针步长为2，慢指针步长为1。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode step_one = head;
        ListNode step_two = head.next;
        while(step_one != step_two) {
            if(step_two == null || step_two.next == null) return false;
            step_one = step_one.next;
            step_two = step_two.next.next;
        }
        return true;
    }
}
```

## 最长上升子序列

https://leetcode-cn.com/problems/longest-increasing-subsequence/

<font color=green>思路</font>+<font color=red>代码</font>

+ 设置一个数组`tail`来保存长度为`i+1`的上升子序列的最小尾数；
+ 依次遍历输入数组，若大于`tail`的尾数，则直接插入到其后；
+ 若小于`tail`的尾数，则替换`tail`中小于当前数的最大数(二分查找)。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len <= 1) return len;
        int[] tail = new int[len];
        tail[0] = nums[0];
        int end = 0;
        for(int i = 1; i < len; ++i) {
            if(nums[i] > tail[end]) {
                end++;
                tail[end] = nums[i];
            }
            else {
                int left = 0, right = end;
                while(left < right) {
                    int mid = left + ((right - left) >>> 1);
                    if(nums[i] <= tail[mid]) right = mid;
                    else left = mid + 1;
                }
                tail[left] = nums[i];
            }
        }
        return ++end;
    }
}
```

## 最长回文子串

https://leetcode-cn.com/problems/longest-palindromic-substring/

<font color=green>思路</font>+<font color=red>代码</font>

1. 动态规划
> + 用一个二维数组存储字符串的`i`到`j`位是否为回文串；
> + 状态转移方程为`dp[i][j] = str[i] == str[j] && (j - i < 3 || dp[i+1][j-1])`；
> + 一个字符串是否为回文串取决于它的左右两端的字符是否相同且去掉这两个字符后的子串是否是回文串；
> + 保存最长回文子串的起始下标和串的长度。

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        boolean[][] dp = new boolean[len][len];
        int start = 0, maxlen = 1;
        char[] str = s.toCharArray();
        for(int i = 0; i < len; ++i) dp[i][i] = true;

        for(int j = 1; j < len; ++j) {
            for(int i = 0; i < j; ++i) {
                dp[i][j] = str[i] == str[j] && (j - i < 3 || dp[i + 1][j - 1]);
                if(dp[i][j]) {
                    int currlen = j - i + 1;
                    if(currlen > maxlen) {
                        start = i;
                        maxlen = currlen;
                    }
                }
            }
        }
        return s.substring(start,start + maxlen);
    }
}
```

2. 中心扩散法
> + 从字符串头开始向后依次以每个字符为中心，做奇数长度和偶数长度的中心扩散；
> + 取最长子串。

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        int maxlen = 1;
        String ans = s.substring(0, 1);
        for(int i = 0; i < len - 1; ++i) {
            String oddPalindrome = centerSpread(s, i, i);
            String evenPalindrome = centerSpread(s, i, i + 1);
            String maxLenString = oddPalindrome.length() > evenPalindrome.length() ? oddPalindrome : evenPalindrome;
            if(maxLenString.length() > maxlen) {
                maxlen = maxLenString.length();
                ans = maxLenString;
            }
        }
        return ans;
    }

    private String centerSpread(String s, int left, int right) {
        int i = left, j = right;
        while(i >= 0 && j < s.length()) {
            if(s.charAt(i) == s.charAt(j)) {
                i--;
                j++;
            }
            else break;
        }
        return s.substring(i + 1, j);
    }
}
```

## 最长有效括号

https://leetcode-cn.com/problems/longest-valid-parentheses/

<font color=green>思路</font>+<font color=red>代码</font>

+ 用一个数组存储各个位置之前的最长有效括号；
+ 只有当左右括号都出现时才会有一对有效括号，所以每次的增量为2，且只有在当前位为`)`才有可能有有效括号；
+ 若同时出现两个`)`则考虑内部最长有效括号之前是否为`(`，且要加上内部括号的长度以及匹配的`(`前的最长有效括号。

```java
class Solution {
    public int longestValidParentheses(String s) {
        if(s.length() < 2) return 0;
        char[] str = s.toCharArray();
        int[] dp = new int[str.length];
        int maxlen = 0;
        for(int i = 1; i < str.length; ++i) {
            if(str[i] == ')') {
                if(str[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                }
                else if(i - dp[i-1] - 1 >= 0 && str[i - dp[i-1] - 1] == '(') {
                    //     内部有效括号                     匹配的左括号前的有效括号     增量
                    dp[i] = dp[i - 1] + (i - dp[i-1] >= 2 ? dp[i - dp[i-1] - 2] : 0) + 2;
                }
            }
            maxlen = maxlen > dp[i] ? maxlen : dp[i];
        }
        return maxlen;
    }
}
```

## 二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

<font color=green>思路</font>+<font color=red>代码</font>

+ dfs遍历二叉树；
+ 当给定的两个节点分别处于左右两子树时，当前节点为最近公共祖先；
+ 仅在`右/左`子树中时，应继续遍历`右/左`子树。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```

## 多数元素

https://leetcode-cn.com/problems/majority-element/

<font color=green>思路</font>+<font color=red>代码</font>

1. 排序取最中间的那个数必然是多数元素。

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

2. 投票法
> + 将多数元素设为`1`非多数元素设为`-1`，则数组和必然大于0；
> + 设一位`count`在其等于`0`时，修改临时多数元素；
> + 最后一位临时多数元素即为真正的多数元素。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int key = nums[0];
        for(int i = 0; i < nums.length; ++i) {
            if(count == 0) key = nums[i];
            if(nums[i] == key) count++;
            else count--;
        }
        return key;
    }
}
```

## 最大矩形

https://leetcode-cn.com/problems/maximal-rectangle/

<font color=green>思路</font>+<font color=red>代码</font>

+ 记录每个点的最大高度，左边界和右边界。
+ 考虑哪些因素会导致矩形左边界的改变。由于当前行之上的全部0已经考虑在当前版本的left中，唯一能影响left就是在当前行遇到0。
+ 因此我们可以定义:
`new_left[j] = max(old_left[j], cur_left)`
+ cur_left是我们遇到的最右边的0的序号加1。当我们将矩形向左 “扩展” ，我们知道，不能超过该点，否则会遇到0。
+ right延用left的方法；
+ 最后用`height[j] * (right[j] - left[j])`计算该点构成的最大矩形面积。

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;
        int rows = matrix.length;
        int cols = matrix[0].length;

        int[] height = new int[cols];
        int[] left = new int[cols];
        int[] right = new int[cols];
        Arrays.fill(right, cols);

        int maxArea = 0;
        for(int i = 0; i < rows; ++i) {
            int cur_left = 0, cur_right = 0;
            for(int j = cols - 1; j >= 0; --j) {
                if(matrix[i][j] == '1') right[j] = Math.min(right[j], cur_right);
                else {
                    right[j] = cols;
                    cur_right = j;
                }
            }
            for(int j = 0; j < cols; ++j) {
                if(matrix[i][j] == '1') {
                    height[j]++;
                    left[j] = Math.max(left[j], cur_left);
                }
                else {
                    height[j] = 0;
                    left[j] = 0;
                    cur_left = j + 1;
                }
            }
            for(int j = 0; j < cols; ++j) {
                maxArea = Math.max(maxArea, height[j] * (right[j] - left[j]));
            }  
        }
        return maxArea;
    }
}
```

## 最大正方形

https://leetcode-cn.com/problems/maximal-square/

<font color=green>思路</font>+<font color=red>代码</font>

+ 接上题的最大矩形，在求面积时用宽和高中较小的那一个做边长求得正方形面积即可。

```java
for(int j = 0; j < col; ++j) {
    int a = Math.min(right[j] - left[j], height[j]);
    ans = Math.max(ans, a * a);
}
```

## 二叉树的最大深度

https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

<font color=green>思路</font>+<font color=red>代码</font>

+ 各节点返回其左右子树深度的最大值加1。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

## 最大子序和

https://leetcode-cn.com/problems/maximum-subarray/

<font color=green>思路</font>+<font color=red>代码</font>

+ 状态转移方程`max = Math.max(nums[i], max + nums[i])`。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int ans = nums[0];
        for(int i = 1; i < nums.length; ++i) {
            max = Math.max(nums[i], max + nums[i]);
            ans = Math.max(max, ans);
        }
        return ans;
    }
}
```

## 乘积最大子数组

https://leetcode-cn.com/problems/maximum-product-subarray/

<font color=green>思路</font>+<font color=red>代码</font>

+ 状态转移方程为`max = Math.max(max * nums[i], nums[i])`；
+ 但是要考虑存在负数的情况，会导致最大值变最小值，最小值变最大值；
+ 故要保存最小值`min = Math.min(min * nums[i], nums[i])`；
+ 当前遍历的数为负数时，需要将最大值和最小值交换再求值。

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = 1, min = 1;
        int ans = nums[0];
        for(int i = 0; i < nums.length; ++i) {
            if(nums[i] < 0) {
                int tmp = max;
                max = min;
                min = tmp;
            }
            max = Math.max(max * nums[i], nums[i]);
            min = Math.min(min * nums[i], nums[i]);
            ans = Math.max(ans, max);
        }
        return ans;
    }
}
```

## 图像渲染

https://leetcode-cn.com/problems/flood-fill/、

<font color=green>思路</font>+<font color=red>代码</font>

+ dfs，考虑新的颜色和之前颜色相同就不用再染。

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int originColor = image[sr][sc];
        if(originColor != newColor)
            dfs(image, sr, sc, newColor, originColor);
        return image;
    }

    public void dfs(int[][] image, int sr, int sc, int newColor, int originColor) {
        if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length)
            return;
        if(image[sr][sc] == originColor) {
            image[sr][sc] = newColor;
            dfs(image, sr - 1, sc, newColor, originColor);
            dfs(image, sr, sc - 1, newColor, originColor);
            dfs(image, sr + 1, sc, newColor, originColor);
            dfs(image, sr, sc + 1, newColor, originColor);
        }
    }
}
```

## 整理字符串

https://leetcode-cn.com/problems/make-the-string-great/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用栈，从后往前依次遍历字符串，若遇到符合规则的则出栈，否则入栈；
+ 最后依次出栈，即得到最终结果。

```java
class Solution {
    public String makeGood(String s) {
        int len = s.length();
        if(len == 0) return "";
        String ans = "";
        Stack<Character> stack = new Stack<Character>();
        for(int i = len - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if(!stack.isEmpty() && Math.abs(stack.peek() - c) == 32 )
                stack.pop();
            else
                stack.push(c);
        }
        while(!stack.isEmpty())
            ans += stack.pop();
        return ans;
    }
}
```

## 寻找两个正序数组的中位数

https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

<font color=green>思路</font>+<font color=red>代码</font>

+ 找两数组中第k小的数；
+ 每次取两数组的前`k/2`位数，将较小的那部分去掉；
+ 最后当`k=1`时，较小的那一位即为两数组的中位数。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int left = (m + n + 1) / 2;//左中位
        int right = (m + n + 2) / 2;//右中位
        //合并偶数和奇数长度两种情况，故做左右两次中位数的查找
        return (getKthMinNum(nums1, 0, m, nums2, 0, n, left) + getKthMinNum(nums1, 0, m, nums2, 0, n, right)) * 0.5;
    }

    public double getKthMinNum(int[] nums1, int start1, int len1, int[]nums2, int start2, int len2, int k) {
        //将短的数组总是置为第一个
        if(len1 > len2) return getKthMinNum(nums2, start2, len2, nums1, start1, len1, k);
        //当短的数组长度为0时，直接求下一个数组的中位数
        if(len1 == 0) return nums2[start2 + k - 1];
        //当找到第k位数时，取两数组当前位置的最小值
        if(k == 1) return Math.min(nums1[start1], nums2[start2]);
        //两数组的前k/2位
        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;
        //去掉较小的那前k/2位
        if(nums1[i] > nums2[j]) return getKthMinNum(nums1, start1, len1, nums2, j + 1, len2 - (j - start2 + 1), k - (j - start2 + 1));
        else return getKthMinNum(nums1, i + 1, len1 - (i - start1 + 1), nums2, start2, len2, k - (i - start1 + 1));
    }
}
```

## 合并区间

https://leetcode-cn.com/problems/merge-intervals/

<font color=green>思路</font>+<font color=red>代码</font>

+ 在以区间头排序之后，相邻两区间仅存在三种情况；
+ 判断区间连接处的位置修改区间尾即可。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (v1,v2) -> v1[0] - v2[0]); //以区间头排序
        int[][] ans = new int[intervals.length][2];
        int index = -1;
        for(int[] interval: intervals) {
            //当结果集中没有值或者当前区间头大于结果集最后一个区间的区间尾时，直接插入到结果集末尾
            if(index == -1 || interval[0] > ans[index][1]) ans[++index] = interval;
            //否则合并区间，修改结果集最后一个区间的区间尾
            else ans[index][1] = Math.max(ans[index][1], interval[1]);
        }
        //返回相应长度的结果集
        return Arrays.copyOf(ans, index + 1);
    }
}
```

## 合并二叉树

https://leetcode-cn.com/problems/merge-two-binary-trees/

<font color=green>思路</font>+<font color=red>代码</font>

+ dfs方法，同序遍历两个二叉树；
+ 遇到null就继续传值null。

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        TreeNode tn = new TreeNode();
        if(t1 == null && t2 == null) return null;
        else if(t1 == null) {
            tn.val = t2.val;
            tn.left = mergeTrees(t1, t2.left);
            tn.right = mergeTrees(t1, t2.right);
        }
        else if(t2 == null) {
            tn.val = t1.val;
            tn.left = mergeTrees(t1.left, t2);
            tn.right = mergeTrees(t1.right, t2);
        }
        else {
            tn.val = t1.val + t2.val;
            tn.left = mergeTrees(t1.left, t2.left);
            tn.right = mergeTrees(t1.right, t2.right);
        }
        return tn;
    }
}
```

## 合并K个升序链表

https://leetcode-cn.com/problems/merge-k-sorted-lists/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用优先级队列（小根堆）的自动排序依次存储各链表头；
+ 再从队列中依次取出，插入到结果链表的尾部。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        for(ListNode list : lists)
            if(list != null) pq.offer(list);
        ListNode ans = new ListNode();
        ListNode cur = ans;
        while(!pq.isEmpty()) {
            cur.next = pq.poll();
            cur = cur.next;
            if(cur.next != null)
                pq.offer(cur.next);
        }
        return ans.next;
    }
}
```

+ 将所有链表两两合并。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        int k = lists.length;
        if(k == 0) return null;
        //控制最后剩余唯一链表
        while(k > 1) {
            int idx = 0;
            for(int i = 0; i < k; i += 2) {
                //若剩余单个链表，放到末尾进行下一轮合并
                if(i == k - 1) lists[idx++] = lists[i];
                //两两合并
                else lists[idx++] = merge2Lists(lists[i], lists[i + 1]);
            }
            //重置剩余链表数量
            k = idx;
        }
        return lists[0];
    }

    public ListNode merge2Lists(ListNode l1, ListNode l2) {
        ListNode ans = new ListNode();
        ListNode cur = ans;
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            }
            else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1 == null ? l2 : l1;
        return ans.next;
    }
}
```

## 最小路径和

https://leetcode-cn.com/problems/minimum-path-sum/

<font color=green>思路</font>+<font color=red>代码</font>

+ 状态转移方程:`grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1])`;

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        if(m == 0) return 0;
        int n = grid[0].length;
        for(int i = 1; i < n; ++i)
            grid[0][i] += grid[0][i - 1];
        for(int i = 1; i < m; ++i)
            grid[i][0] += grid[i - 1][0];
        for(int i = 1; i < m; ++i) {
            for(int j = 1; j < n; ++j) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```

## 移动零

https://leetcode-cn.com/problems/move-zeroes/

<font color=green>思路</font>+<font color=red>代码</font>

+ 记录零的个数`n`；
+ 当已遍历位置存在`0`时将非零数向前移动`n`个位置。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums.length <= 1) return;
        int num = 0;
        for(int i = 0; i < nums.length; ++i) {
            if(nums[i] == 0) num++;
            else if(num != 0){
                nums[i - num] = nums[i];
                nums[i] = 0;
            }
        }
    }
}
```

## 最小覆盖子串

https://leetcode-cn.com/problems/minimum-window-substring/

<font color=green>思路</font>+<font color=red>代码</font>

+ 滑动窗口算法；
+ 先将`T`中所有字母及其数量存入哈希表中；
+ 初始化头指针和尾指针，头指针向前移动；
+ 当头指针所指的字符存在于哈希表中时，对应的数量减1；
+ 当对应数量大于0时，子串长度标准减1；
+ 当子串长度标准减小到0时，尾指针向前移动；
+ 同理，尾指针移动时各项数值对应加1；
+ 当尾指针排除掉非`T`中字符后，记录两指针距离最小的位置；
+ 若遍历过程中没有符合要求的窗口，则返回空字符串，否则返回对应两指针的子串。

```java
class Solution {
    public String minWindow(String s, String t) {
        if(s.length() < t.length()) return "";
        HashMap<Character, Integer> map = new HashMap<>();
        int count = 0;
        for(char c : t.toCharArray()) {
            if(map.containsKey(c))
                map.put(c, map.get(c) + 1);
            else map.put(c, 1);
            count++;
        }
        int front = 0, tail = 0;
        int ansfront = Integer.MAX_VALUE, anstail = 0;
        char[] s_char = s.toCharArray();
        while(front < s_char.length) {
            char c = s_char[front];
            if(map.containsKey(c)) {
                map.put(c, map.get(c) - 1);
                if(map.get(c) >= 0) count--; // 避免重复字符
            }
            while(count == 0) {
                c = s_char[tail];
                if(map.containsKey(c)) {
                    map.put(c, map.get(c) + 1);
                    if(map.get(c) > 0) count++;
                }
                if(count > 0 && front - tail < ansfront - anstail) {
                    ansfront = front;
                    anstail = tail;
                }
                tail++;
            }
            front++;
        }
        if(ansfront == Integer.MAX_VALUE) return "";
        return s.substring(anstail, ansfront + 1);
    }
}
```

## 下一个排列

https://leetcode-cn.com/problems/next-permutation/

<font color=green>思路</font>+<font color=red>代码</font>

+ 从后往前遍历，找到第一个升序的数字位置；
+ 将其后大于它的最小数与其替换；
+ 再将其后数列倒序。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len == 0) return;
        int i = len - 1;
        while(i > 0) {
            //找到第一个正序排列的数
            if(nums[i] > nums[i - 1]) {
                //找到其后比他大的最小数
                for(int j = i; j < len; j++) {
                    if(nums[j] <= nums[i - 1]) {
                        replace(nums, j - 1, i - 1);
                        break;
                    }
                    if(j == len - 1) replace(nums, j, i - 1);
                }
                break;
            }
            i--;
        }
        //倒序其后数组
        while(i < len - 1) {
            for(int j = len - 1; j > i; j--) {
                replace(nums, j, j - 1);
            }
            i++;
        }
    }

    public void replace(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```


## 岛屿数量

https://leetcode-cn.com/problems/number-of-islands/

<font color=green>思路</font>+<font color=red>代码</font>

+ 沉岛算法，依次遍历数组；
+ 见到`1`时，进行递归，将该岛屿的`1`全部替换成`0`;
+ 递归完成后岛屿计数加1。

```java
class Solution {
    public int numIslands(char[][] grid) {
        int num = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == '1') {
                    sink(grid, i, j);
                    num++;
                }
            }
        }
        return num;
    }

    public void sink(char[][] grid, int i, int j) {
        if(grid[i][j] == '0') return;
        grid[i][j] = '0';
        if(i < grid.length - 1) sink(grid, i + 1, j);
        if(i > 0) sink(grid, i - 1, j);
        if(j < grid[0].length - 1) sink(grid, i, j + 1);
        if(j > 0) sink(grid, i, j - 1);
    }
}
```

## 回文链表

https://leetcode-cn.com/problems/palindrome-linked-list/

<font color=green>思路</font>+<font color=red>代码</font>

+ 快指针到链表尾时慢指针刚好在链表中部；
+ 通过快慢指针找到链表后半部分；
+ 将链表后半部分倒序；
+ 头指针和中部的指针同时后移并对比两节点的值。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null) return true;
        ListNode secondhalf = halfEnd(head);
        ListNode revershead = reversList(secondhalf.next);

        ListNode curr = head;
        while(revershead != null) {
            if(curr.val != revershead.val) return false;
            curr = curr.next;
            revershead = revershead.next;
        }
        return true;
    }

    public ListNode reversList(ListNode head) {
        ListNode pre = null;
        ListNode curr = head;
        while(curr != null) {
            ListNode tmp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = tmp;
        }
        return pre;
    }

    public ListNode halfEnd(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

## 回文子串

https://leetcode-cn.com/problems/palindromic-substrings/

<font color=green>思路</font>+<font color=red>代码</font>

1. 暴力法

> 由小到大依次遍历子串，判断是否为回文串。

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        int ans = len;
        for(int i = 1; i < len; ++i) {
            int left = 0, right = i;
            while(right < len) {
                if(isPalindrome(s.substring(left, right + 1))) ans++;
                left++;
                right++;
            }
        }
        return ans;
    }

    public boolean isPalindrome(String s) {
        char[] chararray = s.toCharArray();
        int left = 0, right = chararray.length - 1;
        while(left < right) {
            if(chararray[left] != chararray[right]) return false;
            left++;
            right--;
        }
        return true;
    }
}
```

2. 动态规划法

> 新建dp缓存存储从`j`到`i`的子串是不是回文串；
> 判断时可利用当前串的去头去尾子串进行快速判断。

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        int ans = 0;
        boolean[][] dp = new boolean[len][len];
        for(int i = 0; i < len; i++) {
            for(int j = 0; j <= i; j++) {
                if(s.charAt(i) == s.charAt(j) && (i - j < 2 || dp[j + 1][i - 1])) {
                    dp[j][i] = true;
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

3. 中心扩展法

> 用一个字符或两个字符作为中心；
> 分别向两边扩展判断扩展后的字符串是否为回文串。

```java
class Solution {
    public int countSubstrings(String s) {
        int ans = 0;
        for(int center = 0; center < 2 * s.length() - 1; center++) {
            int left = center / 2;
            int right = left + center % 2;
            while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
                ans++;
                left--;
                right++;
            }
        }
        return ans;
    }
}
```

## 分割等和子集

https://leetcode-cn.com/problems/partition-equal-subset-sum/

<font color=green>思路</font>+<font color=red>代码</font>

+ 新建缓存，记录到第`i`个数字各数字总和是否可以满足；
+ 状态转移方程为`dp[j] = dp[j] || dp[j - nums[i]]`其中`j`为`0-target`的值。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length == 0) return false;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }

        if((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        if(nums[0] <= target) dp[nums[0]] = true;

        for(int i = 1; i < nums.length; i++) {
            for(int j = target; j >= nums[i]; j--) {
                if(dp[target]) return true;
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}
```

## 路径总和Ⅲ

https://leetcode-cn.com/problems/path-sum-iii/

<font color=green>思路</font>+<font color=red>代码</font>

1. 双递归

> （递归一）分别从每个节点出发遍历子树是否有符合条件的路径；
> （递归二）每次遍历子树的过程需要递归计算当前路径是否满足了条件。

```java
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if(root == null) return 0;
        int result = countPath(root, sum);
        return result + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    public int countPath(TreeNode root, int sum) {
        if(root == null) return 0;
        sum -= root.val;
        int result = sum == 0 ? 1 : 0;
        return result + countPath(root.left, sum) + countPath(root.right, sum);
    }
}
```

2. 单递归逆向计数

> 因为从子节点到根节点的路径是唯一的，故路径和是一定的；
> 用数组记录到每个节点所路过的节点值；
> 在每个节点处，从当前节点向前进行值的累加；
> 若等于目标值则符合条件的路径数`+1`。

```java
class Solution {
    public int pathSum(TreeNode root, int sum) {
        return pathSum(root, sum, new int[1000], 0);
    }

    public int pathSum(TreeNode root, int sum, int[] array, int p) {
        if(root == null) return 0;
        int currSum = root.val;
        array[p] = currSum;
        int ans = currSum == sum ? 1 : 0;
        for(int i = p - 1; i >= 0; i--) {
            currSum += array[i];
            if(currSum == sum) ans++;
        }
        int ans_left = pathSum(root.left, sum, array, p + 1);
        int ans_right = pathSum(root.right, sum, array, p + 1);
        return ans + ans_left + ans_right;
    }
}
```

## 完全平方数

https://leetcode-cn.com/problems/perfect-squares/

<font color=green>思路</font>+<font color=red>代码</font>

1. 动态规划

> 最坏情况是全`1`相加；
> 初始化一个长度为`n+1`的缓存空间，存储和为`i`所需要的完全平方数的个数；
> 完全平方数基数`j`，当前数所需完全平方数的个数最小为`i-j*j`的个数加`1`；
> 故状态转移方程为`dp[i] = min(dp[i], dp[i-j*j])`。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for(int i = 0; i <= n; i++) {
            dp[i] = i;
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; i - j * j >= 0; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}
```

2. 贪心+BFS算法

> 将小于`n`的所有完全平方数枚举出来；
> 依次减去最大的，留下的如果不是完全平方数就继续重复；
> 每个循环增加一次计数器，最后所得计数器的值就是要求的结果。

```java
class Solution {
    public int numSquares(int n) {
        ArrayList<Integer> square_nums = new ArrayList<Integer>();
        for(int i = 1; i * i <= n; i++) {
            square_nums.add(i*i);
        }

        Set<Integer> queue = new HashSet<Integer>();
        queue.add(n);
        int level = 0;
        while(queue.size() > 0) {
            level += 1;
            Set<Integer> new_queue = new HashSet<Integer>();
            for(Integer num : queue) {
                for(Integer square_num : square_nums) {
                    if(num.equals(square_num)) return level;
                    else if(num < square_num) break;
                    else new_queue.add(num - square_num);
                }
            }
            queue = new_queue;
        }
        return level;
    }
}
```

## 全排列

https://leetcode-cn.com/problems/permutations/

<font color=green>思路</font>+<font color=red>代码</font>

+ 保存当前构建的排列长度，以及元素的使用情况；
+ 依次遍历各个元素；
+ 当元素未被使用时，将其添加到当前构建的序列之后，并置其状态为已使用；
+ 递归进行下一个元素的添加；
+ 递归完成后将当前层使用的元素状态置回为未使用；
+ 若当前构建的序列长度等于原数组长度，则将其插入到结果集中。

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if(len == 0) return ans;
        Deque<Integer> path = new ArrayDeque<Integer>(len);
        boolean[] used = new boolean[len];

        dfs(nums, len, 0, used, path, ans);
        return ans;
    }

    public void dfs(int[] nums, int len, int depth, boolean[] used, Deque<Integer> path, List<List<Integer>> ans) {
        if(depth == len) {
            ans.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = 0; i < len; i++) {
            if(!used[i]) {
                used[i] = true;
                path.add(nums[i]);
                dfs(nums, len, depth + 1, used, path, ans);
                used[i] = false;
                path.removeLast();
            }
        }
    }
}
```

## 根据身高重建队列

https://leetcode-cn.com/problems/queue-reconstruction-by-height/

<font color=green>思路</font>+<font color=red>代码</font>

+ 按身高升序排列，依次找其所站的位置；
+ 需满足条件，其前面不低于他的人数要等于`people[i][1]`；
+ 即当前占位不低于他与空位数的和要等于如上的值。

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        int len = people.length;
        if(len == 0) return people;
        boolean[] used = new boolean[len];
        int[][] ans = new int[len][2];
        Arrays.sort(people, (v1,v2) -> v1[0] - v2[0]);
        for(int i = 0; i < len; i++) {
            int position = 0;
            for(int j = 0; j < len; j++) {
                if(position == people[i][1] && !used[j]) {
                     ans[j] = people[i];
                     used[j] = true;
                     break;
                }
                if(!used[j] || (used[j] && ans[j][0] >= people[i][0])) position++;
            }
        }
        return ans;
    }
}
```

+ 按`h`降序，`k`升序排列；
+ 依次插入其`k`值索引的位置；
+ 因后插入的人身高必定不高于前插入的人，故`k`值即为其索引位置，会将多余的比其高的人向后挤。

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (v1,v2) -> v1[0] == v2[0] ? v1[1] - v2[1] : v2[0] - v1[0]);
        List<int[]> ans = new LinkedList<int[]>();
        for(int[] i : people)
            ans.add(i[1],i);
        return ans.toArray(new int[people.length][2]);
    }
}
```

## 删除无效括号

https://leetcode-cn.com/problems/remove-invalid-parentheses/

<font color=green>思路</font>+<font color=red>代码</font>

+ BFS

> 每一轮去掉一个`(`or`)`，进行括号有效的判断；
> 当出现有效结果时，则所有结果都会在该层出现；
> 故结果集大于`0`时即返回结果集。

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<>();
        Set<String> set = new HashSet<>();
        set.add(s);
        while(true) {
            for(String str : set) {
                if(isInvalid(str)) ans.add(str);
            }
            if(ans.size() > 0) return ans;
            Set<String> new_set = new HashSet<>();
            for(String str : set) {
                for(int i = 0; i < str.length(); i++) {
                    if(str.charAt(i) == '(' || str.charAt(i) == ')') new_set.add(str.substring(0,i) + str.substring(i+1,str.length()));
                }
            }
            set = new_set;
        }
    }

    public boolean isInvalid(String s) {
        int count = 0;
        char[] cs = s.toCharArray();
        for(int i = 0; i < cs.length; i++) {
            if(cs[i] == '(') count++;
            else if(cs[i] == ')') count--;
            if(count < 0) return false;
        }
        return count == 0;
    }
}
```

+ 回溯

> 先计算出左右括号分别要删除的个数；
> 再利用递归分情况对各字符进行判断并插入新的符合条件的字符串；
> 若到字符串末尾且要减去的左右括号已减完，则把新的字符串插入结果集；
> 在递归的最后，从新字符串中删除当前递归添加的字符以回溯。

```java
class Solution {
    Set<String> ans = new HashSet<>();
    public List<String> removeInvalidParentheses(String s) {
        char[] ss = s.toCharArray();
        int open = 0, close = 0;
        for(int i = 0; i < ss.length; i++) {
            if(ss[i] == '(') open++;
            else if(ss[i] == ')') {
                if(open > 0) open--;
                else close++;
            }
        }
        backTracking(ss, new StringBuilder(), 0, 0, 0, open, close);
        return new ArrayList(ans);
    }

    public void backTracking(char[] cs, StringBuilder sb, int index, int open, int close, int openRem, int closeRem) {
        if(index == cs.length) {
            if(openRem == 0 && closeRem == 0) ans.add(sb.toString());
            return;
        }
        if(cs[index] == '(' && openRem > 0 || cs[index] == ')' && closeRem > 0) {
            backTracking(cs, sb, index+1, open, close, openRem - (cs[index] == '(' ? 1 : 0), closeRem - (cs[index] == ')' ? 1 : 0));
        }
        sb.append(cs[index]);
        if(cs[index] != '(' && cs[index] != ')') {
            backTracking(cs, sb, index+1, open, close, openRem, closeRem);
        }
        else if(cs[index] == '(') {
            backTracking(cs, sb, index+1, open+1, close, openRem, closeRem);
        }
        else if(open > close) {
            backTracking(cs, sb, index+1, open, close+1, openRem, closeRem);
        }
        sb.deleteCharAt(sb.length() - 1);
    }
}
```

## 删除链表的倒数第N个节点

https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

<font color=green>思路</font>+<font color=red>代码</font>

+ 先将一个指针`tail`从头节点开始向后移动`n`次；
+ 若该指针指向`null`则说明要删除的是链表的头节点，故直接返回`head.next`；
+ 否则定义一个新的指针`curr`，它的`next`指针指向头节点；
+ 两指针同时向后移动，当`tail`再次指向`null`时，`curr`的`next`指向要删除的节点；
+ 执行删除操作。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode curr = new ListNode();
        curr.next = head;
        ListNode tail = head;
        for(int i = 1; i <= n; i++) {
            tail = tail.next;
        }

        if(tail == null) return head.next;

        while(tail != null) {
            curr = curr.next;
            tail = tail.next;
        }
        curr.next = curr.next.next;
        return head;
    }
}
```

## 旋转图像

https://leetcode-cn.com/problems/rotate-image/

<font color=green>思路</font>+<font color=red>代码</font>

+ 用一个缓存保存当前遍历的行或列；
+ 每个循环的第一行需要存储第一个数，其他的不需要；
+ 以绕圈的方式遍历方阵，通过读取和修改缓存中的值来修改当前遍历的行或列的除第一个以外的值；
+ 第一行需读取缓存当前循环所存储的第一位来修改其最后一位；
+ 每个绕圈循环结束后调整到内圈。

```java
class Solution {
    public void rotate(int[][] matrix) {
        int left_top = 0;
        int right_bottom = matrix.length - 1;
        int[] cache = new int[matrix.length];
        while(left_top < right_bottom) {
            for(int i = left_top, j = right_bottom; i <= right_bottom; i++, j--) {
                cache[i] = matrix[left_top][i];
                matrix[left_top][i] = matrix[j][left_top];
            }
            matrix[left_top][right_bottom] = cache[left_top];
            for(int i = left_top + 1; i <= right_bottom; i++) {
                int tmp = matrix[i][right_bottom];
                matrix[i][right_bottom] = cache[i];
                cache[i] = tmp; 
            }
            for(int i = right_bottom - 1, j = left_top + 1; i >= left_top; i--, j++) {
                int tmp = matrix[right_bottom][i];
                matrix[right_bottom][i] = cache[j];
                cache[j] = tmp;
            }
            for(int i = right_bottom - 1, j = left_top + 1; i >= left_top; i--, j++) {
                matrix[i][left_top] = cache[j];
            }
            left_top++;
            right_bottom--;
        }
    }
}
```

## 搜索二维矩阵Ⅱ

https://leetcode-cn.com/problems/search-a-2d-matrix-ii/

<font color=green>思路</font>+<font color=red>代码</font>

+ 从右上角或左下角开始搜索（以右上角为例）；
+ 若小于`target`则向下一行搜索；
+ 若大于`target`则向左一列搜索。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length == 0 || matrix[0].length == 0) return false;
        int col = matrix[0].length - 1, row = 0;
        while(row < matrix.length && col >= 0) {
            if(matrix[row][col] == target) return true;
            else if(matrix[row][col] > target) col--;
            else row++; 
        }
        return false;
    }
}
```

## 最短无序连续子数组

https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/

<font color=green>思路</font>+<font color=red>代码</font>

+ 首先找到非升序的子数组；
+ 在此子数组中找到最大值和最小值；
+ 找到该子数组前大于最小值的所有数并重新定位子数组左边界；
+ 同理重新定位子数组右边界。

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        if(nums.length < 2) return 0;
        int left = -1, right = nums.length;
        for(int i = 1; i < right; i++) {
            if(nums[i - 1] > nums[i]) {
                left = i - 1;
                break;
            }
        }
        if(left == -1) return 0;
        for(int i = right - 1; i > 0; i--) {
            if(nums[i] < nums[i - 1]) {
                right = i;
                break;
            }
        }
        if(left == 0 && right == nums.length - 1) return nums.length;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for(int i = left; i <= right; i++) {
            min = nums[i] < min ? nums[i] : min;
            max = nums[i] > max ? nums[i] : max;
        }
        for(int i = 0; i < left; i++) {
            if(nums[i] > min) {
                left = i;
                break;
            }
        }
        for(int i = nums.length - 1; i > right; i--) {
            if(nums[i] < max) {
                right = i;
                break;
            }
        }
        return right - left + 1;
    }
}
```

+ 从左向右遍历；
+ 在遍历过程中，若当前数值小于记录的最大值，则更新子数组右边界；
+ 同理，从右向左遍历，确定子数组左边界。

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        if(len < 2) return 0;
        int left = 0, right = -1;
        int max = nums[0], min = nums[len - 1];
        for(int i = 1; i < len; i++) {
            if(nums[i] < max) right = i;
            else max = nums[i];
            int j = len - i - 1;
            if(nums[j] > min) left = j;
            else min = nums[j];
        }
        return right - left + 1;
    }
}
```

## 只出现一次的数字

https://leetcode-cn.com/problems/single-number/

<font color=green>思路</font>+<font color=red>代码</font>

+ 异或运算具有特殊性质；
+ 任何数与0异或都得其本身，任何数与其本身异或都得0；
+ 且异或运算符合交换律和分配律。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int num : nums) {
            ans ^= num;
        }
        return ans;
    }
}
```

## 滑动窗口最大值

https://leetcode-cn.com/problems/sliding-window-maximum/

<font color=green>思路</font>+<font color=red>代码</font>

+ 先确定前k个数的最大值；
+ 每次滑动窗口时，判断新加入的值是否大于等于最大值；
+ 若成立则更新最大值下标；
+ 判断滑框是否滑过了最大值；
+ 若滑过了，则重新定位当前窗口内的最大值。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        int max = 0;
        for(int i = 0; i < k; i++) {
            if(nums[i] >= nums[max]) max = i;
        }
        ans[0] = nums[max];
        int left = 1, right = k;
        while(right < nums.length) {
            if(nums[right] >= nums[max]) max = right;
            if(left > max) {
                max = left;
                for(int i = left + 1; i <= right; i++) {
                    if(nums[i] >= nums[max]) max = i;
                }
            }
            ans[left] = nums[max];
            right++;
            left++;
        }
        return ans;
    }
}
```

## 颜色分类

https://leetcode-cn.com/problems/sort-colors/

<font color=green>思路</font>+<font color=red>代码</font>

+ 荷兰旗问题
+ 利用三个指针分别指向红色下一个赋值下标，蓝色下一个赋值下标以及当前访问元素；
+ 从左向右遍历，当前元素为红色或蓝色时，分别和两指针下标元素交换；
+ 靠左侧的红色交换后需要再判断一次当前元素，之后再后移当前指针。

```java
class Solution {
    public void sortColors(int[] nums) {
        if(nums.length < 2) return;
        int red = 0, blue = nums.length - 1;
        for(int i = 0; i <= blue; i++) {
            if(nums[i] == 0) swap(nums, i, red++);
            else if(nums[i] == 2) swap(nums, i--, blue--);
        }
    }

    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## 排序链表

https://leetcode-cn.com/problems/sort-list/

<font color=green>思路</font>+<font color=red>代码</font>

+ 归并排序，迭代法；
+ 每次大循环更新归并的长度；
+ 每次小循环依次向后找到两个归并的子链表，合并排序。

```java
class Solution {
    public ListNode sortList(ListNode head) {
        int intv = 1, len = 0;
        ListNode ans, h, h1, h2;
        ans = new ListNode();
        ans.next = head;
        h = head;
        while(h != null) {
            h = h.next;
            len++;
        }
        while(intv < len) {
            ListNode pre = ans;
            h = ans.next;
            while(h != null) {
                h1 = h;
                int i = intv;
                while(i > 0 && h != null) {
                    h = h.next;
                    i--;
                }
                if(i > 0) break;
                h2 = h; i = intv;
                while(i > 0 && h != null) {
                    h = h.next;
                    i--;
                }
                int c1 = intv;
                int c2 = intv - i;
                while(c1 > 0 && c2 > 0) {
                    if(h1.val > h2.val) {
                        pre.next = h2;
                        h2 = h2.next;
                        c2--;
                    }
                    else {
                        pre.next = h1;
                        h1 = h1.next;
                        c1--;
                    }
                    pre= pre.next;
                }
                pre.next = c1 == 0 ? h2 : h1;
                while(c1 > 0 || c2 > 0) {
                    pre = pre.next;
                    c1--;
                    c2--;
                }
                pre.next = h;
            }
            intv *= 2;
        }
        return ans.next;
    }
}
```

## 和为k的子数组

https://leetcode-cn.com/problems/subarray-sum-equals-k/

<font color=green>思路</font>+<font color=red>代码</font>

+ 暴力解法
+ 从左向右，依次以每个元素为起点，向后累加；
+ 若累加到和为`k`则计数加1。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans = 0;
        for(int i = 0; i < nums.length; i++) {
            int sum = 0;
            for(int j = i; j < nums.length; j++) {
                sum += nums[j];
                if(sum == k) ans++;
            }
        }
        return ans;
    }
}
```

+ 前缀和+哈希表
+ 从左向右依次累加，用哈希表保存各前缀和；
+ 若存在`preSum-k`的前缀和，则表示其中有和为`k`的子集。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans = 0;
        int preSum = 0;
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        map.put(0,1);
        for(int i = 0; i < nums.length; i++) {
            preSum += nums[i];
            if(map.containsKey(preSum - k)) ans += map.get(preSum - k);
            map.put(preSum, map.getOrDefault(preSum,0) + 1);
        }
        return ans;
    }
}
```

## 子集

https://leetcode-cn.com/problems/subsets

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用二进制的方法进行子集的组合；
+ 先初始化一个与数组长度相等的全`1`二进制数；
+ 二进制数递减；
+ 每次递减遍历一次原数组，并判断二进制数每一位是否为`1`
+ 若为`1`则将当前遍历到的数组元素添加到当前子集；
+ 遍历完成后将子集添加到结果集；

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> arr = new ArrayList<>();
        ans.add(arr);
        int len = nums.length;
        int code = 1;
        while(len > 1) {
            code <<= 1;
            code += 1;
            len--;
        }
        //code即为全1二进制数
        while(code != 0) {
            int b = code;
            arr = new ArrayList<>();
            for(int i = 0; i < nums.length; i++) {
                if((b & 1) == 1) arr.add(nums[i]);
                b >>= 1;
            }
            ans.add(arr);
            code--;
        }
        return ans;
    }
}
```

## 对称二叉树

https://leetcode-cn.com/problems/symmetric-tree/

<font color=green>思路</font>+<font color=red>代码</font>

+ 递归遍历左右子树是否呈镜像；
+ 返回`true`的情况
> 两子树都为空；
> 两子树根节点值相等`&`左子树的左子树和右子树的右子树呈镜像`&`左子树的右子树和右子树的左子树呈镜像；
+ 当左右子树不相等时返回`false`。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return isSymmetric(root.left, root.right);
    }
    public boolean isSymmetric(TreeNode left, TreeNode right) {
        if(left == null && right == null) return true;
        if(left == null || right == null || left.val != right.val) return false;
        return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);
    }
}
```

## 目标和

https://leetcode-cn.com/problems/target-sum/

<font color=green>思路</font>+<font color=red>代码</font>

+ 递归回溯；
+ 当满足遍历完所有的元素并且运算结果为`S`时，返回`1`。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        return TrackTarget(nums, S, 0, 0);
    }

    public int TrackTarget(int[] nums, int S, int s, int index) {
        int sum = 0;
        if(index >= nums.length) return sum;
        int curr_s = s + nums[index];
        if(index == nums.length - 1 && curr_s == S) sum++;
        else if(index != nums.length - 1) sum += TrackTarget(nums, S, curr_s, index + 1);
        curr_s = s - nums[index];
        if(index == nums.length - 1 && curr_s == S) sum++;
        else if(index != nums.length - 1) sum += TrackTarget(nums, S, curr_s, index + 1);
        return sum;
    }
}
```

+ 动态规划（由于可能存在负数的情况，故需要扩展数组）；
+ dp[j]表示和为`j`的计算方法的个数；
+ `next[j + nums[i]] += dp[j]`num[i]参与运算之后和为`j + nums[i]`故以此更新状态；
+ 最后返回和为`S`的计算方法个数。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int[] dp = new int[2001];
        dp[nums[0] + 1000] = 1;
        dp[-nums[0] + 1000]++;

        for(int i = 1; i < nums.length; i++) {
            int[] next = new int[2001];
            for(int j = 0; j < 2001; j++) {
                if(dp[j] > 0) {
                    next[j + nums[i]] += dp[j];
                    next[j - nums[i]] += dp[j];
                }
            }
            dp = next;
        }

        return dp[S + 1000];
    }
}
```

## 任务调度器

https://leetcode-cn.com/problems/task-scheduler/

<font color=green>思路</font>+<font color=red>代码</font>

+ 将调度时间看作是一个图形；
+ 则其宽为`n+1`（最长无等待时间）；
+ 其高度为`max`，因为在每一个`n+1`的时间里不可能出现重复的任务，则其高度就是任务重复的最多次数；
+ 由于最后一轮不需要等待，则我们将其拿出来单独考虑；
+ 最后一轮出现的任务必定是重复了`max`次的任务；
+ 综上考虑，总时间为`(max-1)*(n+1)+maxCount`与`task.length`的最大值。

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] task_num = new int[26];
        int max = 0;
        for(char task : tasks) {
            task_num[task - 'A']++;
        }
        for(int count : task_num) {
            max = Math.max(count, max);
        }
        int maxCount = 0;
        for(int count : task_num) {
            if(count == max) maxCount++;
        }
        return Math.max(tasks.length, (n + 1) * (max - 1) + maxCount);
    }
}
```

## 有效的括号

https://leetcode-cn.com/problems/valid-parentheses/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用栈来匹配括号；
+ 左括号入栈，右括号若和栈顶不匹配则直接返回`false`；
+ 最后栈为空则匹配成功。

```java
public boolean isValid(String s) {
    if(s.length() % 2 != 0) return false;
    Map<Character, Character> map = new HashMap<>();
    map.put(')','(');
    map.put(']','[');
    map.put('}','{');
    Stack<Character> characters = new Stack<>();
    for(char c : s.toCharArray()) {
        if(c == '(' || c == '[' || c == '{') characters.push(c);
        else if(characters.isEmpty() || !characters.pop().equals(map.get(c))) return false;
    }
    return characters.isEmpty();
}
```

## 接雨水

https://leetcode-cn.com/problems/trapping-rain-water/

<font color=green>思路</font>+<font color=red>代码</font>

+ 左右同时遍历，通过两端的最高高度来判断遍历方向；
+ 由于`max_left/max_right`是由`height[letf - 1]/height[right + 1]`得来的，故通过判断后者即可知道前者的大小；
+ 用两端较小的一方做标准，计算其与当前遍历的值的差值即为当前列可存储的雨水量。

```java
public int trap(int[] height) {
        int ans = 0;
        int max_left = 0;
        int max_right = 0;
        int left = 1;
        int right = height.length - 2;
        for(int i = 1; i < height.length - 1; i++) {
            if(height[left - 1] < height[right + 1]) {
                max_left = Math.max(max_left, height[left - 1]);
                if(max_left > height[left]) ans += max_left - height[left];
                left++;
            }
            else {
                max_right = Math.max(max_right, height[right + 1]);
                if(max_right > height[right]) ans += max_right - height[right];
                right--;
            }
        }
        return ans;
    }
```

## 不同路径

https://leetcode-cn.com/problems/unique-paths/

<font color=green>思路</font>+<font color=red>代码</font>

+ 动态规划；
+ 利用`dp`存储当前行到达每个节点可能的路径数；
+ 由于每个元素只与上一行和前一个元素有关系，故将二维数组简化为一位数组；
+ 所有节点遍历完后最后一个元素即为所求结果。

```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[m];
    Arrays.fill(dp, 1);
    for(int i = 1; i < n; i++) {
        for(int j = 1; j < m; j++) {
            dp[j] = dp[j - 1] + dp[j];
        }
    }
    return dp[m - 1];
}
```

## 单词搜索

https://leetcode-cn.com/problems/word-search/

<font color=green>思路</font>+<font color=red>代码</font>

+ 回溯算法；
+ 利用一个`used`数组存储每个元素是否被使用；
+ 依照单词的顺序，在`board`中搜索；
+ 搜索到第一个字母后，设置当前元素使用状态为`true`，依次遍历当前元素的上下左右四个相邻的元素；
+ 递归完成后，将当前元素的使用状态重设为`false`完成回溯；
+ 当遇到单词最后一个字母切与元素相同时，返回单词搜索成功。

```java
    public boolean exist(char[][] board, String word) {
        Map<Character, Integer> map = new HashMap<>();
        for(int i = 0; i < board.length; i++) {
            for(char c : board[i]) {
                map.put(c, map.getOrDefault(c, 0) + 1);
            }
        }
        char[] word_c = word.toCharArray();
        for(char c : word_c) {
            if(!map.containsKey(c)) return false;
            map.put(c, map.get(c) - 1);
            if(map.get(c) < 0) return false;
        }
        boolean[][] used = new boolean[board.length][board[0].length];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(getNext(board ,word_c,0, word.length(), i, j, used)) return true;
            }
        }
        return false;
    }

    public boolean getNext(char[][] board, char[] word, int index, int length, int row, int col, boolean[][] used) {
        boolean ans = false;
        if(board[row][col] != word[index]) return false;
        else if(index == length - 1) return true;
        else {
            used[row][col] = true;
            if(row > 0 && !used[row - 1][col])
                ans = ans || getNext(board, word, index+1, length, row - 1, col, used);
            if(row < board.length - 1 && !used[row + 1][col])
                ans = ans || getNext(board, word, index+1, length, row + 1, col, used);
            if(col > 0 && !used[row][col - 1])
                ans = ans || getNext(board, word, index+1, length, row, col - 1, used);
            if(col < board[0].length - 1 && !used[row][col + 1])
                ans = ans || getNext(board, word, index+1, length, row, col + 1, used);
            used[row][col] = false;
        }
        return ans;
    }
```

## 验证二叉搜索树

https://leetcode-cn.com/problems/validate-binary-search-tree/

<font color=green>思路</font>+<font color=red>代码</font>

+ 依据二叉搜索树的中序遍历是递增的原理；
+ 保存遍历的上一个节点的值，与当前值做对比，若不是按照递增顺序，则不是二叉搜索树。

```java
    private long lastVal = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val > lastVal) lastVal = root.val;
        else return false;
        return isValidBST(root.right);
    }
```

## 不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

<font color=green>思路</font>+<font color=red>代码</font>

+ 设`n`个节点构成的二叉搜索树为`G(n)`个，以`i`为根节点构成的二叉搜索树为`f(n)`个；

+ 则
  $$
  G(n) = f(1) + f(2)+f(3)+...+f(n)
  $$
  
+ 当`i`作为根节点时，其左子树有`i-1`个节点，其右子树有`n-i`个节点；

+ 故
  $$
  f(i) = G(i-1)*G(n-i)
  $$

+ 所以得到卡特兰数
  $$
  G(n) = G(0)*G(n-1)+G(1)*G(n-2)+G(2)*G(n-3)+...+G(n-1)*G(0)
  $$

```java
public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```

## 整数翻转

https://leetcode-cn.com/problems/reverse-integer/

<font color=green>思路</font>+<font color=red>代码</font>

+ 依次取出末位数放在结果数的末尾；
+ 由于限制了为`Integer`类型的长度，故结果数设置为long型并在在结束时判断。

```java
    public int reverse(int x) {
        long ans = 0;
        while(x != 0) {
            ans = ans * 10 + x % 10;
            x /= 10;
        }
        return ans > Integer.MAX_VALUE || ans < Integer.MIN_VALUE ? 0 : (int) ans;
    }
```

## 字符串转换整数

https://leetcode-cn.com/problems/string-to-integer-atoi/

<font color=green>思路</font>+<font color=red>代码</font>

+ 判断字符串长度是否为0；
+ 跳过所有的空格字符；
+ 判断是否越界；
+ 判断当前字符是否是正负号，若是则标记，若不是也不是数字，则返回`0`；
+ 用`long`型存储结果，将数字字符转换并放到结果数末尾；
+ 在生成结果数的过程中需要判断其是否大于最大整型，若大于则根据标记位返回`Integer.MAX_VALUE`/`Integer.MIN_VALUE`；
+ 最后根据标记位返回相应结果。

```java
    public int myAtoi(String str) {
        int len = str.length();
        if (len == 0) return 0;
        char[] str_c = str.toCharArray();
        int index = 0;
        while(index < len && str_c[index] == ' ') index++;
        boolean signed = false;
        if(index >= len) return 0;
        if(str_c[index] == '-') {
            signed = true;
            index++;
        }
        else if(str_c[index] == '+') index++;
        else if(str_c[index] < '0' || str_c[index] > '9') return 0;
        long ans = 0;
        while(index < len && str_c[index] >= '0' && str_c[index] <= '9') {
            ans = ans * 10 + (str_c[index] - '0');
            if(ans > Integer.MAX_VALUE) return signed ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            index++;
        }
        return signed ? (int)-ans : (int)ans;
    }
```

## 删除排序数组中的重复项

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

<font color=green>思路</font>+<font color=red>代码</font>

+ 依次遍历数据计算重复数的个数`n`，并将非重复数向前移动`n`位；
+ 遍历完成后，数组长度减去`n`即为结果数组的长度。

```java
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if(len < 2) return len;
        int pre = 0;
        int jump = 0;
        for(int i = 1; i < len; i++) {
            if(nums[i] == nums[pre]) jump++;
            else {
                nums[i - jump] = nums[i];
                pre = i;
            }
        }
        return len - jump;
    }
```

## 字符串相乘

https://leetcode-cn.com/problems/multiply-strings/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用竖式乘法进行计算；
+ `num1`分别和`num2`的每一位相乘，并在尾部增加相应个数的`0`；
+ 将每次计算结果相加即为两数的乘积。
+ <font color=red>注：</font>以上的乘法和加法分别通过字符串的形式计算。

```java
    public String multiply(String num1, String num2) {
        if(num1.equals("0") || num2.equals("0")) return "0";
        String ans = multiply(num1, num2.charAt(num2.length() - 1));
        int zero = 1;
        for(int i = num2.length() - 2; i >= 0; i--) {
            String result_i = multiply(num1, num2.charAt(i));
            for(int j = 0; j < zero; j++){
                result_i += '0';
            }
            ans = add(ans, result_i);
            zero++;
        }
        return ans;
    }
    //多位数与单位数相乘
    public String multiply(String num1, char num2) {
        String reverse = "";
        int up = 0;
        for(int i = num1.length() - 1; i >= 0; i--) {
            int result_i = (num1.charAt(i) - '0') * (num2 - '0') + up;

            reverse = reverse + (char)('0' + result_i % 10);
            up = result_i / 10;
        }
        String ans = "";
        if(up != 0) ans += (char)('0' + up);
        for(int i = reverse.length() - 1; i >= 0; i--) {
            ans += reverse.charAt(i);
        }
        return ans;
    }
    //两数相加
    public String add(String num1, String num2) {
        String reverse = "";
        int len1 = num1.length();
        int len2 = num2.length();
        int up = 0;
        for(int i = len1 - 1, j  = len2 - 1; i >= 0 || j >= 0; i--, j--) {
            char c1 = i < 0 ? '0' : num1.charAt(i);
            char c2 = j < 0 ? '0' : num2.charAt(j);
            int result_i = c1 - '0' + c2 - '0' + up;
            reverse += (char)('0' + result_i % 10);
            up = result_i / 10;
        }
        String ans = "";
        if(up != 0) ans += (char)('0' + up);
        for(int i = reverse.length() - 1; i >= 0; i--) {
            ans += reverse.charAt(i);
        }
        return ans;
    }
```

## 旋转链表

https://leetcode-cn.com/problems/rotate-list/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用指针`tail`找到链表的最后一个非空节点以及链表长度；
+ 根据长度`len`和要旋转的次数`k`，计算出非循环跳转的次数`distance`；
+ 在`tail`后移的过程中或移动完成后（要根据上一步中的两个值决定）将`front`指针定位到与`tail`相距`distance`或`k`的位置；
+ 将`front`和`tail`连接的所有节点整体移动到链表头。

```java
    public ListNode rotateRight(ListNode head, int k) {
        //链表为空或者只有一个节点
        if(head == null || head.next == null) return head;
        ListNode tail = head;
        ListNode front = head;
        int len = 1;
        //先移动尾节点
        while(tail.next != null && len <= k) {
            tail = tail.next;
            len++;
        }
//        System.out.println(len);
        //要移动的次数正好等与链表长度
        if(len == k && tail.next == null) return head;
        //移动次数大于链表长度，做余数次旋转
        if(len < k) {
            int distance = k % len;
            while(len - distance > 1) {
                front = front.next;
                distance++;
            }
//            System.out.println("len < k : " +front.val);
        }
        //否则标记要旋转的头节点前的位置
        else {
            while(tail.next != null) {
                tail = tail.next;
                front = front.next;
            }
//            System.out.println("len > k : " + front.val);
        }
        //整个旋转头尾的中间部分
        tail.next = head;
        head = front.next;
        front.next = null;
        return head;
    }
```

## 合并两个有序数组

https://leetcode-cn.com/problems/merge-sorted-array/

<font color=green>思路</font>+<font color=red>代码</font>

+ 从两数组后面开始判断，由于`num1`的长度足够，所以直接从后面开始赋值；
+ 比较两数组当前遍历位置的值的大小，大的直接放到`num1`的`len`处；
+ 最后由于`idx2`小于0则表示`num2`已遍历完，否则需要将剩下的`idx2+1`长度的值直接加到`num1`前面；
+ 故直接使用``。

```java
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int idx1 = m - 1;
        int idx2 = n - 1;
        int len = m + n - 1;
        while(idx1 >= 0 && idx2 >= 0) {
            nums1[len--] = nums1[idx1] > nums2[idx2] ? nums1[idx1--] : nums2[idx2--];
        }
       	//将剩余的num2的数字直接放到num1前
        //idx2在num2遍历完后为-1，所以此处不需要判断
        System.arraycopy(nums2, 0, nums1, 0, idx2 + 1);
    }
```

## 格雷编码

https://leetcode-cn.com/problems/gray-code/

<font color=green>思路</font>+<font color=red>代码</font>

+ 设`G(n)`为`n`位的格雷编码，通过规律可知`G(n+1)`是`G(n)`的头位补`0`及其倒序的头位补`1`的集合；
+ 故只需倒序遍历已生成的编码并在头位补`1`即可得到结果。

```java
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<Integer>();
        //添加初始值0
        ans.add(0);
        int head = 1;
        //n位格雷码
        for(int i = 0; i < n; i++) {
            //倒序遍历当前已生成格雷码
            for(int j = ans.size() - 1; j >= 0; j--) {
                ans.add(head + ans.get(j));
            }
            //头位左移
            head <<= 1;
        }
        return ans;
    }
```

## 二叉搜索树中第k小的元素

https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/

<font color=green>思路</font>+<font color=red>代码</font>

+ 因为中序遍历即为升序，故遍历到第k个元素即为答案。

```java
private int ans = Integer.MIN_VALUE;
    public int kthSmallest(TreeNode root, int k) {
        findKth(root, k);
        return ans;
    }
    public int findKth(TreeNode root, int k) {
        if(k == 0) return 0;
        if(root.left != null) k = findKth(root.left, k);
        if(--k == 0) ans = root.val;
        if(root.right != null) k = findKth(root.right, k);
        return k;
    }
```

## 2的幂

https://leetcode-cn.com/problems/power-of-two/

<font color=green>思路</font>+<font color=red>代码</font>

+ 2的幂为二进制只有一位为`1`的数；
+ 故其与`n-1`做与运算之后必得`0`。

```java
    public boolean isPowerOfTwo(int n) {
        return (n > 0) && (n &= n-1) == 0;
    }
```

## 翻转字符串中的单词

https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/

<font color=green>思路</font>+<font color=red>代码</font>

+ 从左向右依次遍历，碰到空格则将前面遍历过的非空格字符翻转。

```java
    public String reverseWords(String s) {
        int len = s.length();
        if(len <= 0) return s;
        char[] s_char = s.toCharArray();
        int word_start = 0;
        for(int i = 0; i < len; ++i) {
            if(i == len - 1) reverse(s_char, word_start, i);
            else if (s_char[i] == ' ') {
                reverse(s_char, word_start, i - 1);
                word_start = i + 1;
            }
        }
        return String.valueOf(s_char);
    }

    public void reverse(char[] s_char, int start, int end) {
        while(start < end) {
            char tmp = s_char[start];
            s_char[start] = s_char[end];
            s_char[end] = tmp;
            start++;
            end--;
        }
    }
```

## 罗马数字转整数

https://leetcode-cn.com/problems/roman-to-integer/

<font color=green>思路</font>+<font color=red>代码</font>

+ 从右向左遍历；
+ 若当前位置字母对应的值大于上一个遍历的字母的值则将其值加入结果中；
+ 反之，从结果中减去该值。

```java
    public int romanToInt(String s) {
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int pre = 0;
        for(int i = s.length() - 1; i >= 0; --i) {
            int n = map.get(s.charAt(i));
            if(i == s.length() - 1 || n >= pre) {
                ans += n;
                pre = n;
            }
            else ans -= n;
        }
        return ans;
    }
```

## 两数相除

https://leetcode-cn.com/problems/divide-two-integers/

<font color=green>思路</font>+<font color=red>代码</font>

+ 先判断除数的三种特殊情况`-1/0/1`;
+ 将后续的一般情况利用负数来求解以防止越界；
+ 最后根据被除数和除数的初始符号判断结果的符号。

```java
    public int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1) return dividend == Integer.MIN_VALUE ? Integer.MAX_VALUE : -dividend;
        int ans = 0;
        boolean nag_dividend = false, nag_divisor = false;
        if(dividend < 0) nag_dividend = true;
        else dividend = -dividend;
        if(divisor < 0) nag_divisor = true;
        else divisor = -divisor;
        while(dividend <= divisor) {
            dividend -= divisor;
            ans--;
        }
        if(!(nag_dividend ^ nag_divisor)) {
            return ans == Integer.MIN_VALUE ? Integer.MAX_VALUE : -ans;
        }
        return ans;
    }
```

## 有效的数独

https://leetcode-cn.com/problems/valid-sudoku/

<font color=green>思路</font>+<font color=red>代码</font>

+ 为行、列、小方格都建立一个二维数组；
+ 通过行`i`、列`j`可计算`(i/3*3 + j/3)`得到当前遍历的元素处于哪一个小方格；
+ 在遍历的过程中对三个数组进行更新，只要遇到重复的值则返回`false`。

```java
    public boolean isValidSudoku(char[][] board) {
        boolean[][] row = new boolean[9][10];
        boolean[][] col = new boolean[9][10];
        boolean[][] box = new boolean[9][10];

        for(int i = 0; i < 9; ++i) {
            for(int j = 0; j < 9; ++j) {
                if(board[i][j] == '.') continue;
                int curNum = board[i][j] - '0';
                if(row[i][curNum]) return false;
                if(col[j][curNum]) return false;
                if(box[j/3 + i/3*3][curNum]) return false;
                row[i][curNum] = true;
                col[j][curNum] = true;
                box[j/3 + i/3*3][curNum] = true;
            }
        }
        return true;
    }
```

## 外观数列

https://leetcode-cn.com/problems/first-missing-positive/

<font color=green>思路</font>+<font color=red>代码</font>

+ 依据上一轮的字符串计数，并记入结果。

```java
    public String countAndSay(int n) {
        String ans = "1";
        while(n > 1) {
            String new_ans = "";
            int count = 0;
            char c = ans.charAt(0);
            for(int i = 0; i < ans.length(); ++i) {
                if(ans.charAt(i) == c) count++;
                else {
                    new_ans += count + "";
                    new_ans += c + "";
                    count = 1;
                    c = ans.charAt(i);
                }
            }
            new_ans += count + "";
            new_ans += c + "";
            ans = new_ans;
            n--;
        }
        return ans;
    }
```

## 缺失的第一个正整数

https://leetcode-cn.com/problems/first-missing-positive/

<font color=green>思路</font>+<font color=red>代码</font>

+ 利用当前的数组当做哈希表，下标作key值；
+ 若当前元素的值与其对应位置的值匹配不成功（并非判断当前下表和当前元素的值），则将两个元素交换；
+ 否则向后遍历；
+ 遍历完成后再进行一次遍历，第一个匹配不成功的位置，其值即为第一个缺失的正整数。

```java
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for(int i = 0; i < len; ++i) {
            while(nums[i] > 0 && nums[i] < len && nums[nums[i] - 1] != nums[i]) {
                int tmp = nums[i];
                nums[i] = nums[tmp - 1];
                nums[tmp - 1] = tmp;
            }
        }

        for(int i = 0; i < len; ++i) {
            if(nums[i] != i + 1) return i + 1;
        }

        return len + 1;
    }
```

